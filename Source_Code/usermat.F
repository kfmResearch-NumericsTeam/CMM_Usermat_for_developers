*DECK,USERMAT      USERDISTRIB  PARALLEL

!-----------------------------------------------------------------------
!
!     SUBROUTINE USERMAT.F F�R DIE IMPLEMENTIERUNG MECHANISCHER MODELLE
!     F�R EINE NICHTLINEARE FE-ANALYSE VON STAHLBETONPELEMENTEN
!
!
!     PROGRAMMIERUNG:   DR. SLAV DIMITROV, CADFEM GMBH
!                       DR. KAREL THOMA, HOCHSCHULE LUZERN
!                       PATRICK ROOS, HOCHSCHULE LUZERN
!
!     DATUM:            25.08.2014
!
!-----------------------------------------------------------------------

      SUBROUTINE USERMAT(MATID,ELEMID,KDOMINTPT,KLAYER,KSECTPT,
     &                   LDSTEP,ISUBST,KEYCUT,
     &                   NDIRECT,NSHEAR,NCOMP,NSTATEV,NPROP,
     &                   TIME,DTIME,TEMP,DTEMP,
     &                   STRESS,USTATEV,DSDEPL,SEDEL,SEDPL,EPSEQ,
     &                   STRAIN,DSTRAIN,EPSPL,PROP,COORDS,
     &                   VAR0,DEFGRAD_T,DEFGRAD,
     &                   TSSTIF,EPSZZ,
     &                   VAR1,VAR2,VAR3,VAR4,VAR5,
     &                   VAR6,VAR7,VAR8)


!!    INCLUDE FILES
#INCLUDE "IMPCOM.INC"
#INCLUDE "ANSYSDEF.INC"
#INCLUDE "SYSPAR.INC"


!!    VARIABLENDEKLARATIONEN (F�R VORDEFINIERTE VARIABLEN VON USERMAT)

      INTEGER          :: MATID, ELEMID,
     &                    KDOMINTPT, KLAYER, KSECTPT,
     &                    LDSTEP, ISUBST, KEYCUT,
     &                    NDIRECT, NSHEAR, NCOMP, NSTATEV, NPROP

      DOUBLE PRECISION :: TIME,  DTIME, TEMP,  DTEMP,
     &                    SEDEL, SEDPL, EPSEQ, EPSZZ

      DOUBLE PRECISION :: STRESS  (NCOMP  ), USTATEV (NSTATEV),
     &                    DSDEPL  (NCOMP,NCOMP),
     &                    STRAIN  (NCOMP  ), DSTRAIN (NCOMP  ),
     &                    EPSPL   (NCOMP  ), PROP    (NPROP  ),
     &                    COORDS  (3),
     &                    DEFGRAD (3,3),     DEFGRAD_T(3,3),
     &                    TSSTIF  (2)

      DOUBLE PRECISION :: VAR0, VAR1, VAR2, VAR3, VAR4, VAR5,
     &                    VAR6, VAR7, VAR8


!!    EXTERNE SUBROUTINEN/FUNKTIONEN VON ANSYS (F�R PROGRAMMIERUNG USERMAT)

      EXTERNAL         :: WRINQR, ERHANDLER, SYSTOP


!!    LOKALE VARIABLENDEKLARATION (F�R PROGRAMMIERUNG USERMAT)

      CHARACTER*(64)   :: MSG
      INTEGER          :: IOTT, WRINQR
      DOUBLE PRECISION :: ZERO


!!    SPANNUNGSZUST�NDE

      IF (NDIRECT.EQ.2 .AND. NCOMP.EQ.3) THEN

        ! PLANE STRESS
        CALL USERMATPS(MATID,ELEMID,KDOMINTPT,KLAYER,KSECTPT,
     &                 LDSTEP,ISUBST,KEYCUT,
     &                 NDIRECT,NSHEAR,NCOMP,NSTATEV,NPROP,
     &                 TIME,DTIME,TEMP,DTEMP,
     &                 STRESS,USTATEV,DSDEPL,SEDEL,SEDPL,EPSEQ,
     &                 STRAIN,DSTRAIN,EPSPL,PROP,COORDS,
     &                 VAR0,DEFGRAD_T,DEFGRAD,
     &                 TSSTIF,EPSZZ,
     &                 VAR1,VAR2,VAR3,VAR4,VAR5,
     &                 VAR6,VAR7,VAR8)

      ELSE

        ! FEHLERMELDUNG & PROGRAMM-ABBRUCH
        ZERO = 0D0
        MSG = 'USERMAT: ONLY PLANE STRESS SUPPORTED (FATAL)!'
        IOTT = WRINQR(WR_OUTPUT)
        WRITE (IOTT,*) MSG
        CALL ERHANDLER('USERMAT',3010,4,MSG,ZERO,' ')
        CALL SYSTOP(11)

      END IF

      RETURN

      END SUBROUTINE USERMAT


!-------------------------------------------------------------------------------
!
!     SUBROUTINEN F�R SPANNUNGSZUST�NDE
!
!-------------------------------------------------------------------------------


*DECK,USERMAT1D    USERDISTRIB  PARALLEL          ! WIRD NICHT VERWENDET

      SUBROUTINE USERMAT1D(MATID,ELEMID,KDOMINTPT,KLAYER,KSECTPT,
     &                     LDSTEP,ISUBST,KEYCUT,
     &                     NDIRECT,NSHEAR,NCOMP,NSTATEV,NPROP,
     &                     TIME,DTIME,TEMP,DTEMP,
     &                     STRESS,USTATEV,DSDEPL,SEDEL,SEDPL,EPSEQ,
     &                     STRAIN,DSTRAIN,EPSPL,PROP,COORDS,
     &                     VAR0,DEFGRAD_T,DEFGRAD,
     &                     TSSTIF,EPSZZ,
     &                     VAR1,VAR2,VAR3,VAR4,VAR5,
     &                     VAR6,VAR7,VAR8)

      END SUBROUTINE USERMAT1D



*DECK,USERMAT3D    USERDISTRIB  PARALLEL          ! WIRD NICHT VERWENDET

      SUBROUTINE USERMAT3D(MATID,ELEMID,KDOMINTPT,KLAYER,KSECTPT,
     &                     LDSTEP,ISUBST,KEYCUT,
     &                     NDIRECT,NSHEAR,NCOMP,NSTATEV,NPROP,
     &                     TIME,DTIME,TEMP,DTEMP,
     &                     STRESS,USTATEV,DSDEPL,SEDEL,SEDPL,EPSEQ,
     &                     STRAIN,DSTRAIN,EPSPL,PROP,COORDS,
     &                     VAR0,DEFGRAD_T,DEFGRAD,
     &                     TSSTIF,EPSZZ,
     &                     VAR1,VAR2,VAR3,VAR4,VAR5,
     &                     VAR6,VAR7,VAR8)

      END SUBROUTINE USERMAT3D



*DECK,USERMATBM    USERDISTRIB  PARALLEL          ! WIRD NICHT VERWENDET

      SUBROUTINE USERMATBM(MATID,ELEMID,KDOMINTPT,KLAYER,KSECTPT,
     &                     LDSTEP,ISUBST,KEYCUT,
     &                     NDIRECT,NSHEAR,NCOMP,NSTATEV,NPROP,
     &                     TIME,DTIME,TEMP,DTEMP,
     &                     STRESS,USTATEV,DSDEPL,SEDEL,SEDPL,EPSEQ,
     &                     STRAIN,DSTRAIN,EPSPL,PROP,COORDS,
     &                     VAR0,DEFGRAD_T,DEFGRAD,
     &                     TSSTIF,EPSZZ,
     &                     VAR1,VAR2,VAR3,VAR4,VAR5,
     &                     VAR6,VAR7,VAR8)

      END SUBROUTINE USERMATBM



*DECK,USERMATPS    USERDISTRIB  PARALLEL          ! PLANE STRESS

      SUBROUTINE USERMATPS(MATID, ELEMID,KDOMINTPT,KLAYER,KSECTPT,
     &                     LDSTEP,ISUBST,KEYCUT,
     &                     NDIRECT,NSHEAR,NCOMP,NSTATEV,NPROP,
     &                     TIME,DTIME,TEMP,DTEMP,
     &                     STRESS,USTATEV,DSDEPL,SEDEL,SEDPL,EPSEQ,
     &                     STRAIN,DSTRAIN,EPSPL,PROP,COORDS,
     &                     VAR0,DEFGRAD_T,DEFGRAD,
     &                     TSSTIF,EPSZZ,
     &                     VAR1,VAR2,VAR3,VAR4,VAR5,
     &                     VAR6,VAR7,VAR8)


!!    INCLUDE FILES
#INCLUDE "IMPCOM.INC"
#INCLUDE "ANSYSDEF.INC"
#INCLUDE "SYSPAR.INC"


!!    VARIABLENDEKLARATIONEN (F�R VORDEFINIERTE VARIABLEN VON USERMATPS)

      INTEGER          :: MATID, ELEMID,
     &                    KDOMINTPT, KLAYER, KSECTPT,
     &                    LDSTEP, ISUBST, KEYCUT,
     &                    NDIRECT, NSHEAR, NCOMP, NSTATEV, NPROP

      DOUBLE PRECISION :: TIME,  DTIME, TEMP,  DTEMP,
     &                    SEDEL, SEDPL, EPSEQ, EPSZZ

      DOUBLE PRECISION :: STRESS  (NCOMP  ), USTATEV (NSTATEV),
     &                    DSDEPL  (NCOMP,NCOMP),
     &                    STRAIN  (NCOMP  ), DSTRAIN (NCOMP  ),
     &                    EPSPL   (NCOMP  ), PROP    (NPROP  ),
     &                    COORDS  (3),
     &                    DEFGRAD (3,3),     DEFGRAD_T(3,3),
     &                    TSSTIF  (2)

      DOUBLE PRECISION :: VAR0, VAR1, VAR2, VAR3, VAR4, VAR5,
     &                    VAR6, VAR7, VAR8


!!    EXTERNE SUBROUTINEN/FUNKTIONEN VON ANSYS (F�R PROGRAMMIERUNG USERMATPS)

      EXTERNAL         :: WRINQR, ERHANDLER, SYSTOP


!!    LOKALE VARIABLENDEKLARATION (F�R PROGRAMMIERUNG USERMATPS)


      DOUBLE PRECISION :: E_MAT(3,3), SPANNUNGEN(3),
     &                    HAUPT(3), DRUCK(11), DRUCKFELD(12), ZUG(11),
     &                    DRUCKZUG(11)
      DOUBLE PRECISION :: MATERIAL_ORG(76), MATERIAL(60)

      DOUBLE PRECISION :: VX,VY,V0,PHI_0,INT_X,INT_Y,INT_Z
	DOUBLE PRECISION :: R_ROHR,F_ROHR,N_LAYER,H_ELEMENT

      INTEGER          :: STATE(4)
      !DOUBLE COMPLEX   :: EX, EY, GAMMA_XY, I
      INTEGER          :: SCHICHTINFO, DIMENS,NVAL
      INTEGER          :: IREF(4)
      DOUBLE PRECISION :: ZSI(4)

      !DOUBLE PRECISION :: EPS(3)
      !DOUBLE COMPLEX   :: VC, EC, FCC, AUX, K_E

      CHARACTER*(64)   :: MSG
      INTEGER          :: IOTT, WRINQR
      DOUBLE PRECISION :: ZERO

!     VARIABLENDEKLARATION TIMELOCK

      CHARACTER DATE*8, ZEIT*10, ZONE*5
      INTEGER          :: VALUES(8), JAHR, MONAT, TAG, STUNDE, MINUTE,
     &                    ZEITWERT, GRENZWERT, JAHR_E, MONAT_E, TAG_E,
     &                    STUNDE_E, MINUTE_E
      CHARACTER*8      :: HN_
      INTEGER*4        :: RES_HN

!-----------------------------------------------------------------------
!
!     BEGINN USERMAT 3.0
!     (MW, 11.05.2021: KEINE ABLAUFDATUM UND COMPUTERHOST CHECK!!!)
!-----------------------------------------------------------------------
      ZEITWERT=1
      GRENZWERT=2
      RES_HN=1
      IF (ELEMID .EQ. 1 .AND. LDSTEP .EQ. 1 .AND. ISUBST .EQ. 1 .AND.
     &    KLAYER .EQ. 1.AND. KDOMINTPT .EQ. 1 ) THEN
      CALL DATE_AND_TIME(DATE,ZEIT,ZONE,VALUES)
      JAHR = VALUES(1)
      MONAT = VALUES(2)
      TAG = VALUES(3)
      STUNDE = VALUES(5)
      MINUTE = VALUES(6)
      ZEITWERT = MINUTE + STUNDE*60 + TAG*24*60 + MONAT*30*24*60 +
     &           JAHR*12*30*24*60

!     MASCHINENNAMEN
      HN_ = "ibkpika8087"
!      HN_ = "N0004395"
!      HN_ = "IBKNUMBAT"

!     ABLAUFDATUM:
      JAHR_E = 2025
      MONAT_E = 12
      TAG_E = 31
      STUNDE_E = 0
      MINUTE_E = 0
      GRENZWERT = MINUTE_E+STUNDE_E*60+TAG_E*24*60+MONAT_E*30*24*60 +
     &            JAHR_E*12*30*24*60

      CALL CHECK_HN(RES_HN,HN_)

      END IF


      !IF ((ZEITWERT .GT. GRENZWERT)) THEN
          
      ! FEHLERMELDUNG & PROGRAMM-ABBRUCH
      !  ZERO = 0D0
      !  MSG = 'USERMAT: LIZENZ IST ABGELAUFEN!'
      !  IOTT = WRINQR(WR_OUTPUT)
      !  WRITE (IOTT,*) MSG
      !  CALL ERHANDLER('USERMAT',3010,4,MSG,ZERO,' ')
      !  CALL SYSTOP(11)

      !ELSE

      ! UNTERSCHEIDUNG 2D / 3D:
      MATERIAL_ORG = PROP
      DIMENS = MATERIAL_ORG (1)

      IF (ABS(DIMENS-1) .LT. 0.1D0) THEN
        KLAYER = 1
      ELSE
        KLAYER = KLAYER
      END IF
      !PRINT*, KLAYER

      STATE = 0
      HAUPT = 0D0
      DRUCK = 0D0
      DRUCKFELD = 0D0
      DRUCKZUG = 0D0
      ZUG = 0D0

      !! FALLS SCHICHT IM INTERGRATIONSPUNKT GERISSEN K_RISS=0D0 !!

      IF (LDSTEP .EQ. 1) THEN
        IF (ISUBST .GT. 1) THEN
          CALL SUB_CRACKED(USTATEV,NSTATEV,MATERIAL_ORG,NPROP)
         END IF
      ELSE
        CALL SUB_CRACKED(USTATEV,NSTATEV,MATERIAL_ORG,NPROP)
      END IF

      ! SUBROUTINE SCHICHTINFORMATION:
      CALL SUB_SCHICHTINFO(MATERIAL_ORG,KLAYER,SCHICHTINFO,IREF,ZSI)

      ! SUBROUTINE MATERIALZUORDNUNG:
      CALL SUB_MATERIAL(MATERIAL_ORG,SCHICHTINFO,IREF,ZSI,
     &                  KLAYER,ELEMID,MATERIAL)
      !PRINT*, MATERIAL
      ! SUBROUTINE MECHANISCHS MODELL:
      CALL SUB_MECH_MODELL(STRESS,STRAIN,DSTRAIN,MATERIAL,SCHICHTINFO,
     &                     E_MAT,SPANNUNGEN,HAUPT,DRUCK,DRUCKFELD,
     &                     DRUCKZUG,ZUG,STATE)
	
	!Subroutine für die Berücksichtigung von Hohlkörper
	
	H_ELEMENT=MATERIAL_ORG(4)
	N_LAYER=MATERIAL_ORG(3)
	R_ROHR=MATERIAL_ORG(76)
	
	IF (R_ROHR.GT.0D0) THEN
		Call SUB_FAK_HK(KLAYER,N_LAYER,H_ELEMENT,R_ROHR,F_ROHR)
	ELSE
		F_ROHR=1D0
	END IF
	
      ! R�CKGABE SPANNUNGEN & WERKSTOFFMATRIX:
      STRESS(1) = SPANNUNGEN(1)*F_ROHR
      STRESS(2) = SPANNUNGEN(2)*F_ROHR
      STRESS(3) = SPANNUNGEN(3)*F_ROHR

      DSDEPL(1,1) = E_MAT(1,1)*F_ROHR
      DSDEPL(1,2) = E_MAT(1,2)*F_ROHR
      DSDEPL(1,3) = E_MAT(1,3)*F_ROHR
      DSDEPL(2,1) = E_MAT(2,1)*F_ROHR
      DSDEPL(2,2) = E_MAT(2,2)*F_ROHR
      DSDEPL(2,3) = E_MAT(2,3)*F_ROHR
      DSDEPL(3,1) = E_MAT(3,1)*F_ROHR
      DSDEPL(3,2) = E_MAT(3,2)*F_ROHR
      DSDEPL(3,3) = E_MAT(3,3)*F_ROHR


      ! SPEICHERN DER OUTPUT-VARIABLEN:
      USTATEV(1) = STATE(1)
      USTATEV(2) = STATE(2)
      USTATEV(3) = STATE(3)
      USTATEV(4) = STATE(4)

      USTATEV(5) = HAUPT(1)
      USTATEV(6) = HAUPT(2)
      USTATEV(7) = HAUPT(3)

      USTATEV(8) = DRUCK(1)
      USTATEV(9) = DRUCK(2)
      USTATEV(10) = DRUCK(3)
      USTATEV(11) = DRUCK(4)
      USTATEV(12) = DRUCK(5)
      USTATEV(13) = DRUCK(6)
      USTATEV(14) = DRUCK(7)
      USTATEV(15) = DRUCK(8)
      USTATEV(16) = DRUCK(9)
      USTATEV(17) = DRUCK(10)

      USTATEV(18) = DRUCKFELD(1)
      USTATEV(19) = DRUCKFELD(2)
      USTATEV(20) = DRUCKFELD(3)
      USTATEV(21) = DRUCKFELD(4)
      USTATEV(22) = DRUCKFELD(5)
      USTATEV(23) = DRUCKFELD(6)
      USTATEV(24) = DRUCKFELD(7)
      USTATEV(25) = DRUCKFELD(8)
      USTATEV(26) = DRUCKFELD(9)
      USTATEV(27) = DRUCKFELD(10)
      USTATEV(28) = DRUCKFELD(11)

      USTATEV(29) = DRUCKZUG(1)
      USTATEV(30) = DRUCKZUG(2)
      USTATEV(31) = DRUCKZUG(3)
      USTATEV(32) = DRUCKZUG(4)
      USTATEV(33) = DRUCKZUG(5)
      USTATEV(34) = DRUCKZUG(6)
      USTATEV(35) = DRUCKZUG(7)
      USTATEV(36) = DRUCKZUG(8)
      USTATEV(37) = DRUCKZUG(9)
      USTATEV(38) = DRUCKZUG(10)

      USTATEV(39) = ZUG(1)
      USTATEV(40) = ZUG(2)
      USTATEV(41) = ZUG(3)
      USTATEV(42) = ZUG(4)
      USTATEV(43) = ZUG(5)
      USTATEV(44) = ZUG(6)
      USTATEV(45) = ZUG(7)
      USTATEV(46) = ZUG(8)
      USTATEV(47) = ZUG(9)
      USTATEV(48) = ZUG(10)

      USTATEV(49)  = E_MAT(1,1)*F_ROHR
      USTATEV(50)  = E_MAT(1,2)*F_ROHR
      USTATEV(51)  = E_MAT(1,3)*F_ROHR
      USTATEV(52)  = E_MAT(2,1)*F_ROHR
      USTATEV(53)  = E_MAT(2,2)*F_ROHR
      USTATEV(54)  = E_MAT(2,3)*F_ROHR
      USTATEV(55)  = E_MAT(3,1)*F_ROHR
      USTATEV(56)  = E_MAT(3,2)*F_ROHR
      USTATEV(57)  = E_MAT(3,3)*F_ROHR

      USTATEV(58)  = IREF(1)
      USTATEV(59)  = IREF(2)
      USTATEV(60)  = IREF(3)
      USTATEV(61)  = IREF(4)

      USTATEV(62)  = MAX(ZUG(11),DRUCK(11),DRUCKZUG(11),DRUCKFELD(12))


      USTATEV(63)  = COORDS(1)
      USTATEV(64)  = COORDS(2)
      USTATEV(65)  = COORDS(3)

      USTATEV(66) = SPANNUNGEN(1)*F_ROHR
      USTATEV(67) = SPANNUNGEN(2)*F_ROHR
      USTATEV(68) = SPANNUNGEN(3)*F_ROHR

      USTATEV(69) = STRAIN(1)+DSTRAIN(1)
      USTATEV(70) = STRAIN(2)+DSTRAIN(2)
      USTATEV(71) = STRAIN(3)+DSTRAIN(3)
	
	USTATEV(72) = F_ROHR


      CONTINUE

      RETURN

      !END IF

      END SUBROUTINE USERMATPS

!-----------------------------------------------------------------------
!
!     SUBROUTINEN F�R USERMAT 2.0
!
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     �BERGEORDNETE SUBROUTINEN:
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER WERKSTOFFMATRIX F�R
!     STAHLBETONELEMENTE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_MECH_MODELL(SPANNUNGEN_0,DEHNUNGEN_0,DEPS,MATERIAL,
     &                           SCHICHTINFO,E_MAT,SPANNUNGEN,HAUPT,
     &                           DRUCK,DRUCKFELD,DRUCKZUG,ZUG,STATE)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION:
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: SPANNUNGEN_0
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) ::DEHNUNGEN_0, DEPS
      DOUBLE PRECISION, DIMENSION(60), INTENT(IN):: MATERIAL
      INTEGER, INTENT(IN) :: SCHICHTINFO
      DOUBLE PRECISION, DIMENSION(3,3), INTENT(OUT):: E_MAT
      DOUBLE PRECISION, DIMENSION(3), INTENT(OUT):: SPANNUNGEN
      DOUBLE PRECISION, DIMENSION(3), INTENT(OUT):: HAUPT
      DOUBLE PRECISION, DIMENSION(11), INTENT(OUT):: DRUCK, DRUCKZUG,
     &                                               ZUG
      DOUBLE PRECISION, DIMENSION(12), INTENT(OUT):: DRUCKFELD
      INTEGER, DIMENSION(4), INTENT(OUT)         ::  STATE

      DOUBLE COMPLEX  , DIMENSION(3) :: S_HX_I_1,S_HY_I_1,S_HXY_I_1
      DOUBLE COMPLEX  , DIMENSION(3) :: SPANNUNG_C
      DOUBLE COMPLEX  , DIMENSION(3) :: S_HX_I_2,S_HY_I_2,S_HXY_I_2
      DOUBLE COMPLEX  , DIMENSION(3) :: S_HX_I_3,S_HY_I_3,S_HXY_I_3
      DOUBLE COMPLEX  , DIMENSION(3) :: S_HX_I_4,S_HY_I_4,S_HXY_I_4
      DOUBLE PRECISION, DIMENSION(3) :: S_HX,S_HY,S_HXY

      DOUBLE PRECISION :: STEP,EX,EY,GAMMA_XY, E1, E3, THETA
      DOUBLE COMPLEX :: FCC, VC, K_E, EC, FCT, AUX, K_RISS, ECU

      DOUBLE COMPLEX   :: K,THETA_C,E1_C,E3_C
      DOUBLE COMPLEX   :: EX_I_1, EY_I_1, GAMMA_XY_I_1
      DOUBLE COMPLEX   :: EX_I_2, EY_I_2, GAMMA_XY_I_2
      DOUBLE COMPLEX   :: EX_I_3, EY_I_3, GAMMA_XY_I_3
      DOUBLE COMPLEX   :: EX_I_4, EY_I_4, GAMMA_XY_I_4
      DOUBLE COMPLEX   :: EX_COM, EY_COM, GAMMA_XY_COM

      DOUBLE COMPLEX   :: PSIX, PSIY

      INTEGER :: STATE_CAL

      DOUBLE PRECISION, DIMENSION(3) :: EPS

      INTEGER, DIMENSION(2) :: STATE_DF,STATE_ZUG

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE

      SUBROUTINE SUB_S_E_DRUCKFELD(EX,EY,GAMMA_XY,DEPS,MATERIAL,
     &                             SCHICHTINFO,SPANNUNGEN,DRUCKFELD,
     &                             STATE_DF)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
        DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
        INTEGER, INTENT(IN) :: SCHICHTINFO
        DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT):: SPANNUNGEN
        DOUBLE PRECISION, DIMENSION(12), INTENT(OUT) :: DRUCKFELD
        INTEGER, DIMENSION(2), INTENT(OUT) :: STATE_DF
      END SUBROUTINE SUB_S_E_DRUCKFELD

      SUBROUTINE SUB_S_E_ZUG(EX,EY,GAMMA_XY,DEPS,MATERIAL,SCHICHTINFO,
     &                       SPANNUNGEN,ZUG,STATE_ZUG)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
        DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
        INTEGER, INTENT(IN) :: SCHICHTINFO
        DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT):: SPANNUNGEN
        DOUBLE PRECISION, DIMENSION(11), INTENT(OUT) :: ZUG
        INTEGER, DIMENSION(2), INTENT(OUT) :: STATE_ZUG
      END SUBROUTINE SUB_S_E_ZUG

      SUBROUTINE SUB_S_E_DRUCK_ZUG(EX,EY,GAMMA_XY,DEPS,MATERIAL,
     &                             SCHICHTINFO,SPANNUNGEN,DRUCKZUG)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
        DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
        INTEGER, INTENT(IN) :: SCHICHTINFO
        DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT):: SPANNUNGEN
        DOUBLE PRECISION, DIMENSION(11), INTENT(OUT) :: DRUCKZUG
      END SUBROUTINE SUB_S_E_DRUCK_ZUG

      SUBROUTINE SUB_S_E_DRUCK(EX,EY,GAMMA_XY,DEPS,MATERIAL,SCHICHTINFO,
     &                         SPANNUNGEN,DRUCK)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
        DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
        INTEGER, INTENT(IN) :: SCHICHTINFO
        DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT):: SPANNUNGEN
        DOUBLE PRECISION, DIMENSION(11), INTENT(OUT) :: DRUCK
      END SUBROUTINE SUB_S_E_DRUCK

      SUBROUTINE SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
        DOUBLE COMPLEX,  INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: E1, E3
      END SUBROUTINE SUB_E1_E3

      END INTERFACE

      ! VORGABEN:
      HAUPT = 0D0
      DRUCK = 0D0
      DRUCKFELD = 0D0
      DRUCKZUG = 0D0
      ZUG   = 0D0
      STATE = 0
      STATE_ZUG = 0
      STATE_DF = 0
      E_MAT = 0D0
      STATE_CAL = 1

      EX = DEHNUNGEN_0(1)+DEPS(1)
      EY = DEHNUNGEN_0(2)+DEPS(2)
      GAMMA_XY = DEHNUNGEN_0(3)+DEPS(3)

      STEP  = EPSILON(1D0)     ! SCHRITTWEITE F�R NUMERISCHE ABLEITUNG

      ! BEWEHRUNGSRICHTUNGEN:
      PSIX = CMPLX(MATERIAL(11),0D0,KIND=8)
      PSIY = CMPLX(MATERIAL(24),0D0,KIND=8)

      ! BETON
      FCC  = CMPLX(MATERIAL(34),0D0,KIND=8)
      VC   = CMPLX(MATERIAL(35),0D0,KIND=8)

      IF (MATERIAL(36).GE.0D0) THEN
      ! DISS SEELHOFER FORMEL (3.4) S. 56
         ECU = CMPLX(-0.6D0,0D0,KIND=8)*(FCC**CMPLX(1D0/3D0,0D0,KIND=8))
      ELSE
         ECU  = CMPLX(MATERIAL(36),0D0,KIND=8)
      END IF

      K_E = CMPLX(MATERIAL(37),0D0,KIND=8)

      EC  = K_E*(FCC)**CMPLX(1D0/3D0,0D0,KIND=8)
      FCT = CMPLX(0.3D0,0D0,KIND=8)*(FCC*FCC)**CMPLX(1D0/3D0,0D0,KIND=8)

      K_RISS = CMPLX(MATERIAL(40),0D0,KIND=8)

      EX_COM = CMPLX(EX,0D0,KIND=8)
      EY_COM = CMPLX(EY,0D0,KIND=8)
      GAMMA_XY_COM = CMPLX(GAMMA_XY,0D0,KIND=8)

      ! BERECHNUNG DER HAUPTDEHNUNGEN:

      CALL SUB_E1_E3(EX_COM,EY_COM,GAMMA_XY_COM,E1_C,E3_C)

      E1 = REAL(E1_C)
      E3 = REAL(E3_C)

      CALL SUB_THETA_ALLGEMEIN(EX_COM,EY_COM,GAMMA_XY_COM,THETA_C)

      THETA = REAL(THETA_C)

      HAUPT(1) = E1
      HAUPT(2) = E3
      HAUPT(3) = THETA

      ! ABBRUCHKRITERIUM F�R BETONBRUCH:
      IF (REAL(E3) .LT. REAL(ECU)) THEN
        !PRINT *, 'BETONBRUCH!'
        STATE(2) = 1
      ELSE
        STATE(2) = 0
      END IF

      ! VORBEREITUNG DER KOMPLEXEN ABLEITUNG (SCHRITTWEITEN)

      K = CMPLX(-0.5D0,0.5D0*(SQRT(3D0)),KIND=8)

      EX_I_1 = CMPLX(EX,0D0,KIND=8)+K*STEP/CMPLX(2D0,0D0,KIND=8)
      EX_I_2 = CMPLX(EX,0D0,KIND=8)-K*STEP/CMPLX(2D0,0D0,KIND=8)
      EX_I_3 = CMPLX(EX,0D0,KIND=8)+K*STEP
      EX_I_4 = CMPLX(EX,0D0,KIND=8)-K*STEP

      EY_I_1 = CMPLX(EY,0D0,KIND=8)+K*STEP/CMPLX(2D0,0D0,KIND=8)
      EY_I_2 = CMPLX(EY,0D0,KIND=8)-K*STEP/CMPLX(2D0,0D0,KIND=8)
      EY_I_3 = CMPLX(EY,0D0,KIND=8)+K*STEP
      EY_I_4 = CMPLX(EY,0D0,KIND=8)-K*STEP

      GAMMA_XY_I_1 = CMPLX(GAMMA_XY,0D0,KIND=8)+K*STEP/
     &               CMPLX(2D0,0D0,KIND=8)
      GAMMA_XY_I_2 = CMPLX(GAMMA_XY,0D0,KIND=8)-K*STEP/
     &               CMPLX(2D0,0D0,KIND=8)
      GAMMA_XY_I_3 = CMPLX(GAMMA_XY,0D0,KIND=8)+K*STEP
      GAMMA_XY_I_4 = CMPLX(GAMMA_XY,0D0,KIND=8)-K*STEP

      ! BERECHNUNG DER WERKSTOFFMATRIX:
      IF (E3 .LT. 0D0 .AND. E1 .LT. 0D0) THEN
      ! A) MODELL F�R ZWEIACHSIGE DRUCKBEANSPRUCHUNGEN

      ! => TANGENTENSTEIFIGKEITSMATRIX (MIT KOMPLEXER NUM. ABLEITUNG)

      CALL SUB_S_E_DRUCK(EX_I_1,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HX_I_1,DRUCK)

      CALL SUB_S_E_DRUCK(EX_I_2,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HX_I_2,DRUCK)

      CALL SUB_S_E_DRUCK(EX_I_3,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HX_I_3,DRUCK)

      CALL SUB_S_E_DRUCK(EX_I_4,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HX_I_4,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_I_1,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HY_I_1,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_I_2,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HY_I_2,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_I_3,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HY_I_3,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_I_4,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HY_I_4,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_COM,GAMMA_XY_I_1,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HXY_I_1,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_COM,GAMMA_XY_I_2,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HXY_I_2,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_COM,GAMMA_XY_I_3,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HXY_I_3,DRUCK)

      CALL SUB_S_E_DRUCK(EX_COM,EY_COM,GAMMA_XY_I_4,DEPS,MATERIAL,
     &                   SCHICHTINFO,S_HXY_I_4,DRUCK)

      ! BERECHNUNG DER SPANNUNGEN:

      CALL SUB_S_E_DRUCK(EX_COM,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                   SCHICHTINFO,SPANNUNG_C,DRUCK)

      SPANNUNGEN = REAL(SPANNUNG_C)

      STATE(1) = 1
      STATE_CAL = 1

      ELSE IF (E3 .LT. 0D0 .AND. 0D0 <= E1 .AND.
     &         E1 <= REAL((K_RISS*FCT)/EC)) THEN
    ! B) MODELL F�R ZUG- UND DRUCKBEANSPRUCHUGNEN

      CALL SUB_S_E_DRUCK_ZUG(EX_I_1,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_1,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_I_2,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_2,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_I_3,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_3,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_I_4,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_4,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_I_1,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_1,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_I_2,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_2,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_I_3,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_3,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_I_4,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_4,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_COM,GAMMA_XY_I_1,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_1,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_COM,GAMMA_XY_I_2,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_2,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_COM,GAMMA_XY_I_3,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_3,DRUCKZUG)

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_COM,GAMMA_XY_I_4,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_4,DRUCKZUG)

      ! BERECHNUNG DER SPANNUNGEN:

      CALL SUB_S_E_DRUCK_ZUG(EX_COM,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,SPANNUNG_C,DRUCKZUG)

      SPANNUNGEN = REAL(SPANNUNG_C)

      STATE(1) = 2
      STATE_CAL = 1


      ELSE IF (0D0 <= E3 .AND. E3 <= REAL((K_RISS*FCT)/EC) .AND.
     &         0D0 <= E1 .AND. E1 <= REAL((K_RISS*FCT)/EC)) THEN

      ! C) LINEAR ELASTISCHES MATERIALVERHALTEN

      ! => ELASTIZIT�TSMATRIX

      STATE(1) = 3
      STATE_CAL = 2

      AUX = REAL(EC)/(1D0-(REAL(VC)*REAL(VC)))
      E_MAT(1,1) = REAL(AUX)
      E_MAT(1,2) = REAL(AUX)*REAL(VC)
      E_MAT(2,1) = REAL(AUX)*REAL(VC)
      E_MAT(2,2) = REAL(AUX)
      E_MAT(3,3) = REAL(AUX)*((1D0-REAL(VC))/2D0)

      EPS(1)=EX
      EPS(2)=EY
      EPS(3)=GAMMA_XY

      SPANNUNGEN = MATMUL(E_MAT,EPS)


      ELSE IF (E3 .LT. 0D0 .AND. E1 .GT. REAL((K_RISS*FCT)/EC)) THEN

      ! D) GERISSENES SCHEIBENMODELL F�R FE-ANALYSEN

      ! => TANGENTENSTEIFIGKEITSMATRIX (MIT KOMPLEXER NUM. ABLEITUNG)

      CALL SUB_S_E_DRUCKFELD(EX_I_1,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_1,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_I_2,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_2,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_I_3,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_3,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_I_4,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HX_I_4,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_I_1,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_1,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_I_2,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_2,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_I_3,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_3,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_I_4,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HY_I_4,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_COM,GAMMA_XY_I_1,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_1,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_COM,GAMMA_XY_I_2,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_2,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_COM,GAMMA_XY_I_3,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_3,DRUCKFELD,STATE_DF)

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_COM,GAMMA_XY_I_4,DEPS,MATERIAL,
     &                       SCHICHTINFO,S_HXY_I_4,DRUCKFELD,STATE_DF)


      ! BERECHNUNG DER SPANNUNGEN:

      CALL SUB_S_E_DRUCKFELD(EX_COM,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                       SCHICHTINFO,SPANNUNG_C,DRUCKFELD,STATE_DF)

      SPANNUNGEN = REAL(SPANNUNG_C)

      STATE(3) = STATE_DF(1)
      STATE(4) = STATE_DF(2)

      STATE(1) = 4
      STATE_CAL = 1

      ELSE IF (E3 >= 0D0 .AND. E1 .GT. REAL((K_RISS*FCT)/EC)) THEN

      ! E) MODELL F�R ZWEIACHSIGE ZUGBEANSPRUCHUNG

      ! => TANGENTENSTEIFIGKEITSMATRIX (MIT KOMPLEXER NUM. ABLEITUNG)

      CALL SUB_S_E_ZUG(EX_I_1,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HX_I_1,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_I_2,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HX_I_2,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_I_3,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HX_I_3,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_I_4,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HX_I_4,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_I_1,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HY_I_1,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_I_2,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HY_I_2,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_I_3,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HY_I_3,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_I_4,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HY_I_4,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_COM,GAMMA_XY_I_1,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HXY_I_1,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_COM,GAMMA_XY_I_2,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HXY_I_2,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_COM,GAMMA_XY_I_3,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HXY_I_3,ZUG,STATE_ZUG)

      CALL SUB_S_E_ZUG(EX_COM,EY_COM,GAMMA_XY_I_4,DEPS,MATERIAL,
     &                 SCHICHTINFO,S_HXY_I_4,ZUG,STATE_ZUG)

      ! BERECHNUNG DER SPANNUNG

      CALL SUB_S_E_ZUG(EX_COM,EY_COM,GAMMA_XY_COM,DEPS,MATERIAL,
     &                 SCHICHTINFO,SPANNUNG_C,ZUG,STATE_ZUG)

      SPANNUNGEN = REAL(SPANNUNG_C)
      STATE(1) = 5
      STATE(3) = STATE_ZUG(1)
      STATE(4) = STATE_ZUG(2)
      STATE_CAL = 1

      END IF


      IF (STATE_CAL .EQ. 1) THEN

        S_HX  = AIMAG(32D0*(S_HX_I_1-S_HX_I_2)-(S_HX_I_3-S_HX_I_4))/
     &          (15D0*SQRT(3D0)*STEP)

        S_HY  = AIMAG(32D0*(S_HY_I_1-S_HY_I_2)-(S_HY_I_3-S_HY_I_4))/
     &          (15D0*SQRT(3D0)*STEP)

        S_HXY =AIMAG(32D0*(S_HXY_I_1-S_HXY_I_2)-(S_HXY_I_3-S_HXY_I_4))/
     &          (15D0*SQRT(3D0)*STEP)

        ! ENTSPRECHEND ANSYS UMSORTIERTE MATRIX!!
        E_MAT(1,1) = S_HX(1)
        E_MAT(1,2) = S_HY(1)
        E_MAT(1,3) = S_HXY(1)

        E_MAT(2,1) = S_HX(2)
        E_MAT(2,2) = S_HY(2)
        E_MAT(2,3) = S_HXY(2)

        E_MAT(3,1) = S_HX(3)
        E_MAT(3,2) = S_HY(3)
        E_MAT(3,3) = S_HXY(3)

      END IF

      END SUBROUTINE SUB_MECH_MODELL

!-----------------------------------------------------------------------
!     SUBROUTINEN F�R MECHANISCHE MODELLE:
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BESTIMMUNG DES GEW�HLTEN DRUCKFELDMODELLS ZUR
!     BERECHNUNG DER SPANNUNGEN ANHAND DER VERZERRUNGEN
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_DRUCKFELD(EX,EY,GAMMA_XY,DEPS,MATERIAL,
     &                             SCHICHTINFO,SPANNUNGEN,DRUCKFELD,
     &                             STATE_DF)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
      DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
      INTEGER, INTENT(IN) :: SCHICHTINFO
      DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT) :: SPANNUNGEN
      DOUBLE PRECISION, DIMENSION(12), INTENT(OUT) :: DRUCKFELD
      INTEGER, DIMENSION(2), INTENT(OUT) :: STATE_DF

      INTEGER :: MODELL

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE

      SUBROUTINE SUB_S_E_CMM(EX,EY,GAMMA_XY,DEPS,MATERIAL,SCHICHTINFO,
     &                       SPANNUNGEN,DRUCKFELD,STATE_DF)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
        DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
        INTEGER, INTENT(IN) :: SCHICHTINFO
        DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT):: SPANNUNGEN
        DOUBLE PRECISION, DIMENSION(12), INTENT(OUT) :: DRUCKFELD
        INTEGER, DIMENSION(2), INTENT(OUT) :: STATE_DF
      END SUBROUTINE SUB_S_E_CMM

      END INTERFACE

      MODELL = MATERIAL(2)

      ! UNTERSCHEIDUNG DRUCKFELDMODELL

      IF (ABS(MODELL-1.0D0) .LT. 0.1D0) THEN

        CALL SUB_S_E_CMM(EX,EY,GAMMA_XY,DEPS,MATERIAL,SCHICHTINFO,
     &                   SPANNUNGEN,DRUCKFELD,STATE_DF)

      !ELSEIF (ABS(MODELL-1.0D0) .LT. 1.1D0) THEN

        !CALL SUB_S_E_OCF(EX,EY,GAMMA_XY,MATERIAL,SPANNUNGEN,DRUCKFELD,STATE_DF)

      !ELSEIF (ABS(MODELL-1.0D0) .LT. 2.1D0) THEN

        !CALL SUB_S_E_MCFT(EX,EY,GAMMA_XY,MATERIAL,SPANNUNGEN,DRUCKFELD,STATE_DF)

      !END IF

      END IF

      END SUBROUTINE SUB_S_E_DRUCKFELD

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER SPANNUNGEN IN FUNKTION DER
!     VERZERRUNGEN NACH EINEM MODELL F�R ZWEIACHSIGE
!     DRUCKBEANSPRUCHUNGEN
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              03.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_DRUCK(EX,EY,GAMMA_XY,DEPS,MATERIAL,
     &                         SCHICHTINFO,SPANNUNGEN,DRUCK)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
      DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
      INTEGER, INTENT(IN) :: SCHICHTINFO
      DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT) :: SPANNUNGEN
      DOUBLE PRECISION, DIMENSION(11), INTENT(OUT) :: DRUCK

      INTEGER :: DIMENS, STAHL1, STAHL2,STATUS_Q
      INTEGER, DIMENSION(2) :: BETON
      DOUBLE COMPLEX ::   N, HOEHE, CO, CU,
     &                    AS1, DM1, PSI1, FSY1, FSU1, ESU1, ESV1, ES1,
     &                    KA1, KB1, KC1,
     &                    AS2, DM2, PSI2, FSY2, FSU2, ESU2, ESV2, ES2,
     &                    KA2, KB2, KC2,
     &                    FCC, ECU, K_E, VC,
     &                    SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
      DOUBLE COMPLEX :: SIGMA_S1, SIGMA_S2, SIGMA_C1, SIGMA_C3
      DOUBLE COMPLEX :: THETA, E1, E3, DELTA_Z, EC, FC, EPS1, EPS2, PI
      DOUBLE COMPLEX, DIMENSION(3) :: SIGMA_S, SIGMA_C
      DOUBLE PRECISION, DIMENSION(5) :: D_THETA, D_PSI1, D_PSI2

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE

      SUBROUTINE SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: THETA
      END SUBROUTINE SUB_THETA_ALLGEMEIN

      SUBROUTINE SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
        DOUBLE COMPLEX,  INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: E1, E3
      END SUBROUTINE SUB_E1_E3

      SUBROUTINE SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1, E3, FCC, ECU, K_E
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_C3
      END SUBROUTINE SUB_S_E_BETON

      SUBROUTINE SUB_S_E_STAHL(STAHL,EPS,FSY,FSU,ESU,ESV,ES,
     &                         KA,KB,KC,SIGMA_S)
        INTEGER, INTENT(IN) :: STAHL
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL

      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION MIN_RC(VAL1,VAL2)
        DOUBLE COMPLEX :: MIN_RC
        DOUBLE COMPLEX, INTENT(IN) :: VAL1, VAL2
      END FUNCTION MIN_RC

      SUBROUTINE SUB_ZQ(SCHICHTINFO,MATERIAL
     &                  ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATE)
        INTEGER,INTENT(IN)            :: SCHICHTINFO
        DOUBLE PRECISION,DIMENSION(60),INTENT(IN):: MATERIAL
        DOUBLE COMPLEX,INTENT(OUT)    :: SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
        INTEGER,INTENT(INOUT)         :: STATE
      END SUBROUTINE SUB_ZQ

      END INTERFACE

      ! VORGABEN:
      DRUCK = 0D0
      PI = CMPLX(4.0D0*ATAN(1.0D0),0D0,KIND=8)

      ! EINLESEN DER MATERIALKENNWERTE:
      ! ALLGEMEIN:
      DIMENS = MATERIAL(1)

      ! GEOMETRIE:
      N = CMPLX(MATERIAL(3),0D0,KIND=8)
      HOEHE = CMPLX(MATERIAL(4),0D0,KIND=8)
      CO = CMPLX(MATERIAL(5),0D0,KIND=8)
      CU = CMPLX(MATERIAL(6),0D0,KIND=8)

      ! BEWEHRUNG IN X-RICHTUNG:
      STAHL1 = MATERIAL(7)
      AS1 = CMPLX(MATERIAL(9),0D0,KIND=8)
      DM1 = CMPLX(MATERIAL(10),0D0,KIND=8)
      PSI1 = CMPLX(MATERIAL(11),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY1 = CMPLX(MATERIAL(12),0D0,KIND=8)
      FSU1 = CMPLX(MATERIAL(13),0D0,KIND=8)
      ESU1 = CMPLX(MATERIAL(14),0D0,KIND=8)
      ESV1 = CMPLX(MATERIAL(15),0D0,KIND=8)
      ES1 = CMPLX(MATERIAL(16),0D0,KIND=8)
      KA1 = CMPLX(MATERIAL(17),0D0,KIND=8)
      KB1 = CMPLX(MATERIAL(18),0D0,KIND=8)
      KC1 = CMPLX(MATERIAL(19),0D0,KIND=8)

      ! BEWEHRUNG IN Y-RICHTUNG:
      STAHL2 = MATERIAL(20)
      AS2 = CMPLX(MATERIAL(22),0D0,KIND=8)
      DM2 = CMPLX(MATERIAL(23),0D0,KIND=8)
      PSI2 = CMPLX(MATERIAL(24),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY2 = CMPLX(MATERIAL(25),0D0,KIND=8)
      FSU2 = CMPLX(MATERIAL(26),0D0,KIND=8)
      ESU2 = CMPLX(MATERIAL(27),0D0,KIND=8)
      ESV2 = CMPLX(MATERIAL(28),0D0,KIND=8)
      ES2 = CMPLX(MATERIAL(29),0D0,KIND=8)
      KA2 = CMPLX(MATERIAL(30),0D0,KIND=8)
      KB2 = CMPLX(MATERIAL(31),0D0,KIND=8)
      KC2 = CMPLX(MATERIAL(32),0D0,KIND=8)

      ! BER�CKSICHTIGUNG GENEIGTER BEWEHRUNG:
      D_PSI1(1) = REAL(ABS(ABS(REAL(PSI1))))                 ! PSI1 = 0
      D_PSI1(2) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI1(3) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)))        ! PSI1 = 180
      D_PSI1(4) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI1(5) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*2D0))    ! PSI1 = 360

      D_PSI2(1) = REAL(ABS(ABS(REAL(PSI2))))                 ! PSI1 = 0
      D_PSI2(2) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI2(3) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)))        ! PSI1 = 180
      D_PSI2(4) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI2(5) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*2D0))    ! PSI1 = 360

      IF (MIN(D_PSI1(1),D_PSI1(2),D_PSI1(3),D_PSI1(4),D_PSI1(5))
     &    .LT. 1D-2) THEN
      ES1 = ES1
      ESU1 = ESU1
      ESV1 = ESV1
      ELSE
      ES1 = ES1 !COS(PSI1)*COS(PSI1)*ES1
      ESU1 = ESU1 !/(COS(PSI1)*COS(PSI1))
      ESV1 = ESV1 !/(COS(PSI1)*COS(PSI1))
      ENDIF

      IF (MIN(D_PSI2(1),D_PSI2(2),D_PSI2(3),D_PSI2(4),D_PSI2(5))
     &    .LT. 1D-2) THEN
      ES2 = ES2
      ESU2 = ESU2
      ESV2 = ESV2
      ELSE
      ES2=  ES2 ! SIN(PSI2)*SIN(PSI2)*ES2
      ESU2 = ESU2 !/(SIN(PSI2)*SIN(PSI2))
      ESV2 = ESV2 !/(SIN(PSI2)*SIN(PSI2))
      ENDIF

      ! BETON:
      IF (ABS(MATERIAL(33)-1.0D0) .LT. 0.1D0) THEN
        BETON(1) = 3
      ELSE
        BETON(1) = MATERIAL(33)
      END IF
      BETON(2) = MATERIAL(41)
      FCC = CMPLX(MATERIAL(34),0D0,KIND=8)
      VC = CMPLX(MATERIAL(35),0D0,KIND=8)
      ECU = CMPLX(MATERIAL(36),0D0,KIND=8)
      K_E = CMPLX(MATERIAL(37),0D0,KIND=8)

      ! BERECHNUNGEN BETONKENNWERTE:
      EC = K_E*FCC**CMPLX((1D0/3D0),0D0,KIND=8)

      ! HILFSWERTE:
      DELTA_Z = HOEHE/N

      ! HAUPTVERZERRUNGEN:
      CALL SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
      CALL SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)

      ! KONTROLLE THETA
      D_THETA(1) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)/2D0))
      D_THETA(2) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*1.5D0))
      D_THETA(3) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)))
      D_THETA(4) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*2D0))
      D_THETA(5) = REAL(ABS(REAL(THETA)))

      ! BETONHAUPTSPANNUNGEN:
      CALL SUB_S_E_BETON(BETON,CMPLX(0D0,0D0,KIND=8),E1,FCC,ECU,
     &                   K_E,SIGMA_C1)
      CALL SUB_S_E_BETON(BETON,CMPLX(0D0,0D0,KIND=8),E3,FCC,ECU,
     &                   K_E,SIGMA_C3)


      SIGMA_C(1) = SIGMA_C1*COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &               COS(THETA)*COS(THETA)
      SIGMA_C(2) = SIGMA_C1*SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &               SIN(THETA)*SIN(THETA)
      SIGMA_C(3) = SIGMA_C1*(-SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))) + SIGMA_C3*
     &               (-SIN(THETA)*COS(THETA))

      FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &     CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &     CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &      CMPLX(30D0,0D0,KIND=8)*E1)))

      ! STAHLSPANNUNGEN:
      IF (MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN
        EPS1 = EX
      ELSE IF (MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2) THEN
        EPS1 = EY
      ELSE
        EPS1 = EX*COS(-PSI1)*COS(-PSI1)+EY*SIN(-PSI1)*SIN(-PSI1)+
     &         GAMMA_XY*(-SIN(-PSI1)*COS(-PSI1))
      END IF


      IF (MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2 ) THEN
        EPS2 = EY
      ELSE IF (MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2 ) THEN
        EPS2 = EX
      ELSE
        EPS2 = EX*COS(-PSI2)*COS(-PSI2)+EY*SIN(-PSI2)*SIN(-PSI2)+
     &         GAMMA_XY*(-SIN(-PSI2)*COS(-PSI2))
      END IF


      IF (REAL(DM1) .GT. 0.1D0) THEN
        CALL SUB_S_E_STAHL(STAHL1,EPS1,FSY1,FSU1,ESU1,ESV1,ES1,KA1,
     &                     KB1,KC1,SIGMA_S1)
      ELSE
        SIGMA_S1 = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (REAL(DM2) .GT. 0.1D0) THEN
        CALL SUB_S_E_STAHL(STAHL2,EPS2,FSY2,FSU2,ESU2,ESV2,ES2,KA2,
     &                     KB2,KC2,SIGMA_S2)
      ELSE
        SIGMA_S2 = CMPLX(0D0,0D0,KIND=8)
      END IF

      ! UNTERSCHEIDUNG 2D / 3D:
      IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 4) THEN
        AS2 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S2 = CMPLX(0D0,0D0,KIND=8)
      ELSE IF (SCHICHTINFO .EQ. 2 .OR. SCHICHTINFO .EQ. 3) THEN
        AS1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S1 = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (ABS(DIMENS-1) .LT. 0.1D0) THEN
        SIGMA_S(1) = SIGMA_S1*COS(-PSI1)*COS(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2*COS(-PSI2)*COS(-PSI2)*(AS2/HOEHE)
        SIGMA_S(2) = SIGMA_S1*SIN(-PSI1)*SIN(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2*SIN(-PSI2)*SIN(-PSI2)*(AS2/HOEHE)
        SIGMA_S(3) = SIGMA_S1*(-SIN(-PSI1)*COS(-PSI1))*(AS1/HOEHE)+
     &               SIGMA_S2*(-SIN(-PSI2)*COS(-PSI2))*(AS2/HOEHE)

      ELSE
        SIGMA_S(1) = SIGMA_S1*COS(-PSI1)*COS(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2*COS(-PSI2)*COS(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(2) = SIGMA_S1*SIN(-PSI1)*SIN(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2*SIN(-PSI2)*SIN(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(3) = SIGMA_S1*(-SIN(-PSI1)*COS(-PSI1))*(AS1/DELTA_Z)+
     &               SIGMA_S2*(-SIN(-PSI2)*COS(-PSI2))*(AS2/DELTA_Z)

      END IF

      ! SPANNUNGEN TOTAL:
      SPANNUNGEN(1) = (CMPLX(1D0,0D0,KIND=8)/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(1)+(VC/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(2)+SIGMA_S(1)
      SPANNUNGEN(2) = (CMPLX(1D0,0D0,KIND=8)/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(2)+(VC/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(1)+SIGMA_S(2)
      SPANNUNGEN(3) = SIGMA_C(3)+SIGMA_S(3)


      ! SPANNUNGEN INFOLGE QUERKRAFT!

      STATUS_Q=MATERIAL(56)

      IF (STATUS_Q.GT.0) THEN

        STATUS_Q=1 ! AUFRUF �BER CMM (MODELL 4)

        CALL SUB_ZQ(SCHICHTINFO,MATERIAL
     &             ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATUS_Q)

        SPANNUNGEN(1) = SPANNUNGEN(1)+SIGX_Q
        SPANNUNGEN(2) = SPANNUNGEN(2)+SIGY_Q
        SPANNUNGEN(3) = SPANNUNGEN(3)+TAUXY_Q

      ELSE

       STATUS_Q=10

      END IF

      ! AUSGABEWERTE:
      DRUCK(1) = REAL(SIGMA_C1)
      DRUCK(2) = REAL(SIGMA_C3)
      DRUCK(3) = REAL(E1)
      DRUCK(4) = REAL(E3)
      DRUCK(5) = REAL(FC)
      DRUCK(6) = REAL(SIGMA_S1)
      DRUCK(7) = REAL(SIGMA_S2)
      DRUCK(8) = REAL(EPS1)
      DRUCK(9) = REAL(EPS2)
      DRUCK(10) = REAL(THETA)
      DRUCK(11) = RHO_Z

      END SUBROUTINE SUB_S_E_DRUCK

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER SPANNUNGEN IN FUNKTION DER
!     VERZERRUNGEN NACH EINEM MODELL F�R ZUG- UND DRUCKBEANSPRUCHUNGEN
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              03.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_DRUCK_ZUG(EX,EY,GAMMA_XY,DEPS,MATERIAL,
     &                             SCHICHTINFO,SPANNUNGEN,DRUCKZUG)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
      DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
      INTEGER, INTENT(IN) :: SCHICHTINFO
      DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT) :: SPANNUNGEN
      DOUBLE PRECISION, DIMENSION(11), INTENT(OUT) :: DRUCKZUG

      INTEGER :: DIMENS, STAHL1, STAHL2,STATUS_Q
      INTEGER, DIMENSION(2) :: BETON
      DOUBLE COMPLEX ::   N, HOEHE, CO, CU,
     &                    AS1, DM1, PSI1, FSY1, FSU1, ESU1, ESV1, ES1,
     &                    KA1, KB1, KC1,
     &                    AS2, DM2, PSI2, FSY2, FSU2, ESU2, ESV2, ES2,
     &                    KA2, KB2, KC2,
     &                    FCC, ECU, K_E, VC,
     &                   SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
      DOUBLE COMPLEX :: SIGMA_S1, SIGMA_S2, SIGMA_C1, SIGMA_C3
      DOUBLE COMPLEX :: THETA, E1, E3, DELTA_Z, EC, FC, EPS1, EPS2, PI
      DOUBLE COMPLEX, DIMENSION(3) :: SIGMA_S, SIGMA_C
      DOUBLE PRECISION, DIMENSION(5) :: D_THETA, D_PSI1, D_PSI2

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE

      SUBROUTINE SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: THETA
      END SUBROUTINE SUB_THETA_ALLGEMEIN

      SUBROUTINE SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
        DOUBLE COMPLEX,  INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: E1, E3
      END SUBROUTINE SUB_E1_E3

      SUBROUTINE SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1, E3, FCC, ECU, K_E
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_C3
      END SUBROUTINE SUB_S_E_BETON

      SUBROUTINE SUB_S_E_STAHL(STAHL,EPS,FSY,FSU,ESU,ESV,ES,
     &                         KA,KB,KC,SIGMA_S)
        INTEGER, INTENT(IN) :: STAHL
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL

      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION MIN_RC(VAL1,VAL2)
        DOUBLE COMPLEX :: MIN_RC
        DOUBLE COMPLEX, INTENT(IN) :: VAL1, VAL2
      END FUNCTION MIN_RC

      SUBROUTINE SUB_ZQ(SCHICHTINFO,MATERIAL
     &                  ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATE)
        INTEGER,INTENT(IN)            :: SCHICHTINFO
        DOUBLE PRECISION,DIMENSION(60),INTENT(IN):: MATERIAL
        DOUBLE COMPLEX,INTENT(OUT)    :: SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
        INTEGER,INTENT(INOUT)         :: STATE
      END SUBROUTINE SUB_ZQ

      END INTERFACE

      ! VORGABEN:
      PI = CMPLX(4.0D0*ATAN(1.0D0),0D0,KIND=8)
      DRUCKZUG = 0D0

      ! EINLESEN DER MATERIALKENNWERTE:
      ! ALLGEMEIN:
      DIMENS = MATERIAL(1)

      ! GEOMETRIE:
      N = CMPLX(MATERIAL(3),0D0,KIND=8)
      HOEHE = CMPLX(MATERIAL(4),0D0,KIND=8)
      CO = CMPLX(MATERIAL(5),0D0,KIND=8)
      CU = CMPLX(MATERIAL(6),0D0,KIND=8)

      ! BEWEHRUNG IN X-RICHTUNG:
      STAHL1 = MATERIAL(7)
      AS1 = CMPLX(MATERIAL(9),0D0,KIND=8)
      DM1 = CMPLX(MATERIAL(10),0D0,KIND=8)
      PSI1 = CMPLX(MATERIAL(11),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY1 = CMPLX(MATERIAL(12),0D0,KIND=8)
      FSU1 = CMPLX(MATERIAL(13),0D0,KIND=8)
      ESU1 = CMPLX(MATERIAL(14),0D0,KIND=8)
      ESV1 = CMPLX(MATERIAL(15),0D0,KIND=8)
      ES1 = CMPLX(MATERIAL(16),0D0,KIND=8)
      KA1 = CMPLX(MATERIAL(17),0D0,KIND=8)
      KB1 = CMPLX(MATERIAL(18),0D0,KIND=8)
      KC1 = CMPLX(MATERIAL(19),0D0,KIND=8)

      ! BEWEHRUNG IN Y-RICHTUNG:
      STAHL2 = MATERIAL(20)
      AS2 = CMPLX(MATERIAL(22),0D0,KIND=8)
      DM2 = CMPLX(MATERIAL(23),0D0,KIND=8)
      PSI2 = CMPLX(MATERIAL(24),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY2 = CMPLX(MATERIAL(25),0D0,KIND=8)
      FSU2 = CMPLX(MATERIAL(26),0D0,KIND=8)
      ESU2 = CMPLX(MATERIAL(27),0D0,KIND=8)
      ESV2 = CMPLX(MATERIAL(28),0D0,KIND=8)
      ES2 = CMPLX(MATERIAL(29),0D0,KIND=8)
      KA2 = CMPLX(MATERIAL(30),0D0,KIND=8)
      KB2 = CMPLX(MATERIAL(31),0D0,KIND=8)
      KC2 = CMPLX(MATERIAL(32),0D0,KIND=8)

      ! BER�CKSICHTIGUNG GENEIGTER BEWEHRUNG:
      D_PSI1(1) = REAL(ABS(ABS(REAL(PSI1))))                 ! PSI1 = 0
      D_PSI1(2) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI1(3) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)))        ! PSI1 = 180
      D_PSI1(4) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI1(5) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*2D0))    ! PSI1 = 360

      D_PSI2(1) = REAL(ABS(ABS(REAL(PSI2))))                 ! PSI1 = 0
      D_PSI2(2) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI2(3) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)))        ! PSI1 = 180
      D_PSI2(4) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI2(5) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*2D0))    ! PSI1 = 360

      IF (MIN(D_PSI1(1),D_PSI1(2),D_PSI1(3),D_PSI1(4),D_PSI1(5))
     &    .LT. 1D-2) THEN
      ES1 = ES1
      ESU1 = ESU1
      ESV1 = ESV1
      ELSE
      ES1 = ES1 !COS(PSI1)*COS(PSI1)*ES1
      ESU1 = ESU1 !/(COS(PSI1)*COS(PSI1))
      ESV1 = ESV1 !/(COS(PSI1)*COS(PSI1))
      ENDIF

      IF (MIN(D_PSI2(1),D_PSI2(2),D_PSI2(3),D_PSI2(4),D_PSI2(5))
     &    .LT. 1D-2) THEN
      ES2 = ES2
      ESU2 = ESU2
      ESV2 = ESV2
      ELSE
      ES2=  ES2 !SIN(PSI2)*SIN(PSI2)*ES2
      ESU2 = ESU2 !/(SIN(PSI2)*SIN(PSI2))
      ESV2 = ESV2 !/(SIN(PSI2)*SIN(PSI2))
      ENDIF

      ! BETON:
      BETON(1) = MATERIAL(33)
      BETON(2) = MATERIAL(41)
      FCC = CMPLX(MATERIAL(34),0D0,KIND=8)
      VC = CMPLX(MATERIAL(35),0D0,KIND=8)
      ECU = CMPLX(MATERIAL(36),0D0,KIND=8)
      K_E = CMPLX(MATERIAL(37),0D0,KIND=8)

      ! BERECHNUNGEN BETONKENNWERTE:
      EC = K_E*FCC**CMPLX((1D0/3D0),0D0,KIND=8)

      ! HILFSWERTE:
      DELTA_Z = HOEHE/N

      ! HAUPTVERZERRUNGEN:
      CALL SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)
      CALL SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)

      ! KONTROLLE THETA
      D_THETA(1) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)/2D0))
      D_THETA(2) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*1.5D0))
      D_THETA(3) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)))
      D_THETA(4) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*2D0))
      D_THETA(5) = REAL(ABS(REAL(THETA)))

      ! BETONSPANNUNGEN:
      SIGMA_C1 = E1*EC
      CALL SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      SIGMA_C(1) = SIGMA_C1*COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &               COS(THETA)*COS(THETA)
      SIGMA_C(2) = SIGMA_C1*SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &               SIN(THETA)*SIN(THETA)
      SIGMA_C(3) = SIGMA_C1*(-SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))) + SIGMA_C3*
     &               (-SIN(THETA)*COS(THETA))


      FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &     CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &     CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &     CMPLX(30D0,0D0,KIND=8)*E1)))

      ! STAHLSPANNUNGEN:
      IF (MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN
        EPS1 = EX
      ELSE IF (MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2) THEN
        EPS1 = EY
      ELSE
        EPS1 = EX*COS(-PSI1)*COS(-PSI1)+EY*SIN(-PSI1)*SIN(-PSI1)+
     &         GAMMA_XY*(-SIN(-PSI1)*COS(-PSI1))
      END IF

      IF (MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2 ) THEN
        EPS2 = EY
      ELSE IF (MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2) THEN
        EPS2 = EX
      ELSE
        EPS2 = EX*COS(-PSI2)*COS(-PSI2)+EY*SIN(-PSI2)*SIN(-PSI2)+
     &         GAMMA_XY*(-SIN(-PSI2)*COS(-PSI2))
      END IF

      IF (REAL(DM1) .GT. 0.1D0) THEN
        CALL SUB_S_E_STAHL(STAHL1,EPS1,FSY1,FSU1,ESU1,ESV1,ES1,KA1,
     &                     KB1,KC1,SIGMA_S1)
      ELSE
        SIGMA_S1 = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (REAL(DM2) .GT. 0.1D0) THEN
        CALL SUB_S_E_STAHL(STAHL2,EPS2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                     KA2,KB2,KC2,SIGMA_S2)
      ELSE
        SIGMA_S2 = CMPLX(0D0,0D0,KIND=8)
      END IF

      ! UNTERSCHEIDUNG 2D / 3D:

      IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 4) THEN
        AS2 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S2 = CMPLX(0D0,0D0,KIND=8)
      ELSE IF (SCHICHTINFO .EQ. 2 .OR. SCHICHTINFO .EQ. 3) THEN
        AS1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S1 = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (ABS(DIMENS-1) .LT. 0.1D0) THEN
        SIGMA_S(1) = SIGMA_S1*COS(-PSI1)*COS(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2*COS(-PSI2)*COS(-PSI2)*(AS2/HOEHE)
        SIGMA_S(2) = SIGMA_S1*SIN(-PSI1)*SIN(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2*SIN(-PSI2)*SIN(-PSI2)*(AS2/HOEHE)
        SIGMA_S(3) = SIGMA_S1*(-SIN(-PSI1)*COS(-PSI1))*(AS1/HOEHE)+
     &               SIGMA_S2*(-SIN(-PSI2)*COS(-PSI2))*(AS2/HOEHE)

      ELSE
        SIGMA_S(1) = SIGMA_S1*COS(-PSI1)*COS(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2*COS(-PSI2)*COS(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(2) = SIGMA_S1*SIN(-PSI1)*SIN(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2*SIN(-PSI2)*SIN(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(3) = SIGMA_S1*(-SIN(-PSI1)*COS(-PSI1))*(AS1/DELTA_Z)+
     &               SIGMA_S2*(-SIN(-PSI2)*COS(-PSI2))*(AS2/DELTA_Z)

      END IF


      ! SPANNUNGEN TOTAL:
      SPANNUNGEN(1) = (CMPLX(1D0,0D0,KIND=8)/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(1)+(VC/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(2)+SIGMA_S(1)
      SPANNUNGEN(2) = (CMPLX(1D0,0D0,KIND=8)/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(2)+(VC/(CMPLX(1D0,0D0,KIND=8)-
     &                (VC*VC)))*SIGMA_C(1)+SIGMA_S(2)
      SPANNUNGEN(3) = SIGMA_C(3)+SIGMA_S(3)

          ! SPANNUNGEN INFOLGE QUERKRAFT!

      STATUS_Q=MATERIAL(56)

      IF (STATUS_Q.GT.0) THEN

        STATUS_Q=2 ! AUFRUF �BER CMM (MODELL 4)

        CALL SUB_ZQ(SCHICHTINFO,MATERIAL
     &             ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATUS_Q)

        SPANNUNGEN(1) = SPANNUNGEN(1)+SIGX_Q
        SPANNUNGEN(2) = SPANNUNGEN(2)+SIGY_Q
        SPANNUNGEN(3) = SPANNUNGEN(3)+TAUXY_Q

      ELSE

       STATUS_Q=10

      END IF

      ! AUSGABEWERTE:
      DRUCKZUG(1) = REAL(SIGMA_C1)
      DRUCKZUG(2) = REAL(SIGMA_C3)
      DRUCKZUG(3) = REAL(E1)
      DRUCKZUG(4) = REAL(E3)
      DRUCKZUG(5) = REAL(FC)
      DRUCKZUG(6) = REAL(SIGMA_S1)
      DRUCKZUG(7) = REAL(SIGMA_S2)
      DRUCKZUG(8) = REAL(EPS1)
      DRUCKZUG(9) = REAL(EPS2)
      DRUCKZUG(10) = REAL(THETA)
      DRUCKZUG(11) = REAL(RHO_Z)

      END SUBROUTINE SUB_S_E_DRUCK_ZUG

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER SPANNUNGEN IN FUNKTION DER
!     VERZERRUNGEN NACH DEM GERISSENEN SCHEIBENMODELL
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              03.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_CMM(EX,EY,GAMMA_XY,DEPS,MATERIAL,SCHICHTINFO,
     &                       SPANNUNGEN,DRUCKFELD,STATE_DF)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
      DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
      INTEGER, INTENT(IN) :: SCHICHTINFO
      DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT) :: SPANNUNGEN
      DOUBLE PRECISION, DIMENSION(12), INTENT(OUT) :: DRUCKFELD
      INTEGER, DIMENSION(2), INTENT(OUT) :: STATE_DF

      DOUBLE COMPLEX :: SIGMA_C1, SIGMA_C3, THETA, E1, E3, E10, E30,
     &                  FC, EX0, EY0, GAMMA_XY0
      DOUBLE COMPLEX, DIMENSION(3) :: SIGMA_C, SIGMA_S

      DOUBLE COMPLEX ::   N, HOEHE, CO, CU,
     &                    AS1, DM1, PSI1, FSY1, FSU1, ESU1, ESV1, ES1,
     &                    KA1, KB1, KC1,
     &                    AS2, DM2, PSI2, FSY2, FSU2, ESU2, ESV2, ES2,
     &                    KA2, KB2, KC2,
     &                    FCC, ECU, K_E, THETA_B0, THETA_B1, K_RISS,
     &                    LAMBDA, SRM1_VORGABE, SRM2_VORGABE, VC
      DOUBLE COMPLEX ::   RHO1, RHO2, FCT, EC, DELTA_Z, HOEHE_FIKTIV,
     &                    C, ZS1, ZS2, ZO, SR10, SR20, PI,
     &                    SRM1, SRM2, SRM,
     &                    SIGMA_S1R, SIGMA_S2R, TAU_B0, TAU_B1,
     &                    WCR1, WCR2, EPS1, EPS2,
     &                    SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
      INTEGER :: STAHL1, STAHL2, ZM1, ZM2, DIMENS, BEGRENZUNG,STATUS_Q
      INTEGER, DIMENSION(2) :: BETON

      DOUBLE PRECISION, DIMENSION(5) :: D_PSI1, D_PSI2, D_THETA

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE

      SUBROUTINE SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: THETA
      END SUBROUTINE SUB_THETA_ALLGEMEIN

      SUBROUTINE SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
        DOUBLE COMPLEX,  INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: E1, E3
      END SUBROUTINE SUB_E1_E3

      SUBROUTINE SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1, E3, FCC, ECU, K_E
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_C3
      END SUBROUTINE SUB_S_E_BETON

      SUBROUTINE SUB_S_E_STAHL(STAHL,EPS,FSY,FSU,ESU,ESV,ES,
     &                         KA,KB,KC,SIGMA_S)
        INTEGER, INTENT(IN) :: STAHL
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL

      SUBROUTINE SUB_S_E_ZM(ZM,ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,
     &                      TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)
        INTEGER, INTENT(IN) :: ZM
        DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ESV,
     &                                ES,TAU_B0,TAU_B1,EC,RHO,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_SR
      END SUBROUTINE SUB_S_E_ZM

      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION ABS_CC(VAL)
        DOUBLE COMPLEX :: ABS_CC
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_CC

      FUNCTION MIN_RC(VAL1,VAL2)
        DOUBLE COMPLEX :: MIN_RC
        DOUBLE COMPLEX, INTENT(IN) :: VAL1, VAL2
        END FUNCTION MIN_RC

      SUBROUTINE SUB_ZQ(SCHICHTINFO,MATERIAL
     &                  ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATE)
        INTEGER,INTENT(IN)            :: SCHICHTINFO
        DOUBLE PRECISION,DIMENSION(60),INTENT(IN):: MATERIAL
        DOUBLE COMPLEX,INTENT(OUT)    :: SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
        INTEGER,INTENT(INOUT)         :: STATE
      END SUBROUTINE SUB_ZQ

      END INTERFACE

      ! VORGABEN:

      DRUCKFELD = 0D0
      STATE_DF = 0

      PI = CMPLX(4.0D0*ATAN(1.0D0),0D0,KIND=8)

      ! EINLESEN DER MATERIALKENNWERTE:
      ! ALLGEMEIN:
      DIMENS = MATERIAL(1)

      ! GEOMETRIE:
      N = CMPLX(MATERIAL(3),0D0,KIND=8)
      HOEHE = CMPLX(MATERIAL(4),0D0,KIND=8)
      CO = CMPLX(MATERIAL(5),0D0,KIND=8)
      CU = CMPLX(MATERIAL(6),0D0,KIND=8)

      ! BEWEHRUNG IN X-RICHTUNG:
      STAHL1 = MATERIAL(7)
      ZM1 = MATERIAL(8)
      AS1 = CMPLX(MATERIAL(9),0D0,KIND=8)
      DM1 = CMPLX(MATERIAL(10),0D0,KIND=8)
      PSI1 = CMPLX(MATERIAL(11),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY1 = CMPLX(MATERIAL(12),0D0,KIND=8)
      FSU1 = CMPLX(MATERIAL(13),0D0,KIND=8)
      ESU1 = CMPLX(MATERIAL(14),0D0,KIND=8)
      ESV1 = CMPLX(MATERIAL(15),0D0,KIND=8)
      ES1 = CMPLX(MATERIAL(16),0D0,KIND=8)
      KA1 = CMPLX(MATERIAL(17),0D0,KIND=8)
      KB1 = CMPLX(MATERIAL(18),0D0,KIND=8)
      KC1 = CMPLX(MATERIAL(19),0D0,KIND=8)

      ! BEWEHRUNG IN Y-RICHTUNG:
      STAHL2 = MATERIAL(20)
      ZM2 = MATERIAL(21)
      AS2 = CMPLX(MATERIAL(22),0D0,KIND=8)
      DM2 = CMPLX(MATERIAL(23),0D0,KIND=8)
      PSI2 = CMPLX(MATERIAL(24),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY2 = CMPLX(MATERIAL(25),0D0,KIND=8)
      FSU2 = CMPLX(MATERIAL(26),0D0,KIND=8)
      ESU2 = CMPLX(MATERIAL(27),0D0,KIND=8)
      ESV2 = CMPLX(MATERIAL(28),0D0,KIND=8)
      ES2 = CMPLX(MATERIAL(29),0D0,KIND=8)
      KA2 = CMPLX(MATERIAL(30),0D0,KIND=8)
      KB2 = CMPLX(MATERIAL(31),0D0,KIND=8)
      KC2 = CMPLX(MATERIAL(32),0D0,KIND=8)

      ! BER�CKSICHTIGUNG GENEIGTER BEWEHRUNG:
      D_PSI1(1) = REAL(ABS(ABS(REAL(PSI1))))                 ! PSI1 = 0
      D_PSI1(2) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI1(3) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)))        ! PSI1 = 180
      D_PSI1(4) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI1(5) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*2D0))    ! PSI1 = 360

      D_PSI2(1) = REAL(ABS(ABS(REAL(PSI2))))                 ! PSI1 = 0
      D_PSI2(2) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI2(3) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)))        ! PSI1 = 180
      D_PSI2(4) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI2(5) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*2D0))    ! PSI1 = 360

      IF (MIN(D_PSI1(1),D_PSI1(2),D_PSI1(3),D_PSI1(4),D_PSI1(5))
     &   .LT. 1D-2) THEN
      ES1 = ES1
      ESU1 = ESU1
      ESV1 = ESV1
      ELSE
      ES1 = ES1 !COS(PSI1)*COS(PSI1)*ES1
      ESU1 = ESU1 !/(COS(PSI1)*COS(PSI1))
      ESV1 = ESV1 !/(COS(PSI1)*COS(PSI1))
      ENDIF

      IF (MIN(D_PSI2(1),D_PSI2(2),D_PSI2(3),D_PSI2(4),D_PSI2(5))
     &   .LT. 1D-2) THEN
      ES2 = ES2
      ESU2 = ESU2
      ESV2 = ESV2
      ELSE
      ES2=  ES2 ! SIN(PSI2)*SIN(PSI2)*ES2
      ESU2 = ESU2 ! /(SIN(PSI2)*SIN(PSI2))
      ESV2 = ESV2 ! /(SIN(PSI2)*SIN(PSI2))
      ENDIF

      ! BETON:
      BETON(1) = MATERIAL(33)
      BETON(2) = MATERIAL(41)
      FCC = CMPLX(MATERIAL(34),0D0,KIND=8)
      VC = CMPLX(MATERIAL(35),0D0,KIND=8)
      ECU = CMPLX(MATERIAL(36),0D0,KIND=8)
      K_E = CMPLX(MATERIAL(37),0D0,KIND=8)
      THETA_B0 = CMPLX(MATERIAL(38),0D0,KIND=8)
      THETA_B1 = CMPLX(MATERIAL(39),0D0,KIND=8)
      K_RISS = CMPLX(MATERIAL(40),0D0,KIND=8)

      ! RISSABSTAND:
      LAMBDA = CMPLX(MATERIAL(42),0D0,KIND=8)
      SRM1_VORGABE = CMPLX(MATERIAL(43),0D0,KIND=8)
      SRM2_VORGABE = CMPLX(MATERIAL(44),0D0,KIND=8)
      BEGRENZUNG = MATERIAL(45)

      ! BERECHNUNGEN BETONKENNWERTE:
      EC = K_E*FCC**CMPLX((1D0/3D0),0D0,KIND=8)
      FCT = CMPLX(0.3D0,0D0,KIND=8)*(FCC*FCC)**
     &      CMPLX((1D0/3D0),0D0,KIND=8)

      TAU_B0 = THETA_B0*FCT
      TAU_B1 = THETA_B1*FCT

      ! BERECHNUNG DER FIKTIVEN SCHICHTH�HE
      DELTA_Z = HOEHE/N

      ! BERECHNUNG DER SCHICHTH�HEN
      IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 2) THEN
      ZS1 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CU-(DM1/CMPLX(2D0,0D0,KIND=8))
      ZS2 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CU-DM1-
     &       (DM2/CMPLX(2D0,0D0,KIND=8))
      ELSE IF (SCHICHTINFO .EQ. 3 .OR. SCHICHTINFO .EQ. 4) THEN
      ZS1 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CO-(DM1/CMPLX(2D0,0D0,KIND=8))
      ZS2 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CO-DM1-
     &       (DM2/CMPLX(2D0,0D0,KIND=8))
      ELSE
      C = (CO+CU)/CMPLX(2D0,0D0,KIND=8)
      ZS1 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-C-(DM1/CMPLX(2D0,0D0,KIND=8))
      ZS2 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-C-DM1-
     &       (DM2/CMPLX(2D0,0D0,KIND=8))
      END IF

      ZO = (ZS1+ZS2)/CMPLX(2D0,0D0,KIND=8)
      HOEHE_FIKTIV = ((HOEHE/CMPLX(2D0,0D0,KIND=8))-(ZO))*
     &                CMPLX(2D0,0D0,KIND=8)

      IF (REAL(HOEHE_FIKTIV) .GT. REAL(HOEHE/
     &    CMPLX(2D0,0D0,KIND=8))) THEN
            HOEHE_FIKTIV = HOEHE/CMPLX(2D0,0D0,KIND=8)
      END IF

      IF (ABS(DIMENS-1) .LT. 0.1D0 .OR. ABS(REAL(N)-1D0)
     &    .LT. 0.1D0)THEN
        RHO1 = AS1/(HOEHE_FIKTIV*CMPLX(2D0,0D0,KIND=8))
        RHO2 = AS2/(HOEHE_FIKTIV*CMPLX(2D0,0D0,KIND=8))
      ELSE
        RHO1 = AS1/(HOEHE_FIKTIV)
        RHO2 = AS2/(HOEHE_FIKTIV)
      END IF

      ! BERECHNUNG DER SPANNUNGEN:

      ! HAUPTVERZERRUNGEN:
      CALL SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)

      ! RISSNEIGUNG:
      CALL SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)

      ! KONTROLLE THETA
      D_THETA(1) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)/2D0))
      D_THETA(2) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*1.5D0))
      D_THETA(3) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)))
      D_THETA(4) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*2D0))
      D_THETA(5) = REAL(ABS(REAL(THETA)))


      CALL SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
      SIGMA_C1 = CMPLX(0D0,0D0,KIND=8)


      FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &     CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &     CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &     CMPLX(30D0,0D0,KIND=8)*E1)))


      SIGMA_C(1) = SIGMA_C1*COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &             COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &             COS(THETA)*COS(THETA)
      SIGMA_C(2) = SIGMA_C1*SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &             SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &             SIN(THETA)*SIN(THETA)
      SIGMA_C(3) = SIGMA_C1*(-SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &             COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))) + SIGMA_C3*
     &             (-SIN(THETA)*COS(THETA))


      ! MAXIMALE RISSABST�NDE
      SR10 = (DM1*FCT*(CMPLX(1D0,0D0,KIND=8)-RHO1))/
     &       (CMPLX(2D0,0D0,KIND=8)*TAU_B0*RHO1)
      SR20 = (DM2*FCT*(CMPLX(1D0,0D0,KIND=8)-RHO2))/
     &       (CMPLX(2D0,0D0,KIND=8)*TAU_B0*RHO2)

      ! DIAGONALER RISSABSTAND:
      SRM = LAMBDA/((ABS_C(SIN(THETA+PSI1))/SR10)+
     &      (ABS_C(SIN(THETA+PSI2))/SR20))

      ! FESTLEGUNG DER RISSABST�NDE:
      IF (MIN(D_THETA(3),D_THETA(4),D_THETA(5)) .LT. 1D-2
     &   .AND. MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN

        SRM1 = CMPLX(0D0,0D0,KIND=8)
        SRM2 = SRM/ABS_C(SIN(THETA+PSI2))

      ELSE IF (MIN(D_THETA(3),D_THETA(4),D_THETA(5)) .LT. 1D-2
     &   .AND. MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2) THEN

        SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
        SRM2 = CMPLX(0D0,0D0,KIND=8)

      ELSE IF (MIN(D_THETA(1),D_THETA(2)) .LT. 1D-2
     &        .AND. MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2) THEN

        SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
        SRM2 = CMPLX(0D0,0D0,KIND=8)

      ELSE IF (MIN(D_THETA(1),D_THETA(2)) .LT. 1D-2
     &        .AND. MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2) THEN

        SRM1 = CMPLX(0D0,0D0,KIND=8)
        SRM2 = SRM/ABS_C(SIN(THETA+PSI2))

      ELSE
        SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
        SRM2 = SRM/ABS_C(SIN(THETA+PSI2))
      END IF

      ! BEGRENZUNG DER RISSABST�NDE:
      IF (ABS(BEGRENZUNG-1D0) .LT. 0.1D0) THEN
        IF (REAL(SRM1) .GT. REAL(LAMBDA*SR10)) THEN
          SRM1 = LAMBDA*SR10
        END IF

        IF (REAL(SRM2) .GT. REAL(LAMBDA*SR20)) THEN
          SRM2 = LAMBDA*SR20
        END IF
      END IF

      ! VORGABE DER RISSABST�NDE:
      IF (ABS(REAL(SRM1_VORGABE)-1D0) .LT. 0.1D0) THEN
        SRM1 = SRM1
      ELSE
        SRM1 = SRM1_VORGABE
      END IF

      IF (ABS(REAL(SRM2_VORGABE)-1D0) .LT. 0.1D0) THEN
        SRM2 = SRM2
      ELSE
        SRM2 = SRM2_VORGABE
      END IF

      ! ELIMINIERUNG SRM WENN KEINE BEWEHRUNG VORHANDEN IST
      IF (REAL(DM1) .GT. 0.1D0) THEN
        SRM1 = SRM1
      ELSE
        SRM1 = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (REAL(DM2) .GT. 0.1D0) THEN
        SRM2 = SRM2
      ELSE
        SRM2 = CMPLX(0D0,0D0,KIND=8)
      END IF

      ! BERECHNUNG STAHLSPANNUNGEN:

      ! MITTLERE STAHLDEHNUNGEN:
      IF (MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN
        EPS1 = EX
      ELSE IF (MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2) THEN
        EPS1 = EY
      ELSE
        EPS1 = EX*COS(-PSI1)*COS(-PSI1)+EY*SIN(-PSI1)*SIN(-PSI1)+
     &         GAMMA_XY*(-SIN(-PSI1)*COS(-PSI1))
      END IF

      IF (MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2 ) THEN
        EPS2 = EY
      ELSE IF (MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2 ) THEN
        EPS2 = EX
      ELSE
        EPS2 = EX*COS(-PSI2)*COS(-PSI2)+EY*SIN(-PSI2)*SIN(-PSI2)+
     &         GAMMA_XY*(-SIN(-PSI2)*COS(-PSI2))
      END IF


      IF (REAL(EPS1) >= 0D0 .AND. REAL(SRM1) .GT. 0D0) THEN
        CALL SUB_S_E_ZM(ZM1,EPS1,SRM1,DM1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                  TAU_B0,TAU_B1,EC,RHO1,KA1,KB1,KC1,SIGMA_S1R)
      ELSE
        IF (REAL(DM1) .GT. 0.1D0) THEN
          CALL SUB_S_E_STAHL(STAHL1,EPS1,FSY1,FSU1,ESU1,ESV1,ES1,KA1,
     &                       KB1,KC1,SIGMA_S1R)
        ELSE
          SIGMA_S1R = CMPLX(0D0,0D0,KIND=8)
        END IF
      END IF

      IF (REAL(EPS2) .GE. 0D0 .AND. REAL(SRM2) .GT. 0D0) THEN
        CALL SUB_S_E_ZM(ZM2,EPS2,SRM2,DM2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                  TAU_B0,TAU_B1,EC,RHO2,KA2,KB2,KC2,SIGMA_S2R)
      ELSE
        IF (REAL(DM2) .GT. 0.1D0) THEN
          CALL SUB_S_E_STAHL(STAHL2,EPS2,FSY2,FSU2,ESU2,ESV2,ES2,KA2,
     &                       KB2,KC2,SIGMA_S2R)
        ELSE
          SIGMA_S2R = CMPLX(0D0,0D0,KIND=8)
        END IF
      END IF

      ! BERECHNUNG DER RISSWEITEN:
      WCR1 = EPS1*SRM1
      WCR2 = EPS2*SRM2

      ! ABBRUCHKRITERIUM F�R STAHLREISSEN
      IF (ABS(REAL(SIGMA_S1R)) .GE. REAL(FSY1) .AND.
     &    ABS(REAL(SIGMA_S1R)) .LT. REAL(FSU1)) THEN
          !PRINT *, 'BEWEHRUNG IN X-RICHTUNG AM FLIESSEN!'
          STATE_DF(1) = 1
      ELSE IF (ABS(REAL(SIGMA_S1R)) .GE. REAL(FSU1)) THEN
          !PRINT *, 'BEWEHRUNG IN X-RICHTUNG GERISSEN!'
          STATE_DF(1) = 2
      END IF

      IF (ABS(REAL(SIGMA_S2R)) .GE. REAL(FSY2) .AND.
     &    ABS(REAL(SIGMA_S2R)) .LT. REAL(FSU2)) THEN
          !PRINT *, 'BEWEHRUNG IN Y-RICHTUNG AM FLIESSEN!'
          STATE_DF(2) = 1
      ELSE IF (ABS(REAL(SIGMA_S2R)) .GE. REAL(FSU2)) THEN
          !PRINT *, 'BEWEHRUNG IN Y-RICHTUNG GERISSEN!'
          STATE_DF(2) = 2
      END IF


      ! UNTERSCHEIDUNG 2D / 3D:
      IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 4) THEN
        AS2 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S2R = CMPLX(0D0,0D0,KIND=8)
      ELSE IF (SCHICHTINFO .EQ. 2 .OR. SCHICHTINFO .EQ. 3) THEN
        AS1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S1R = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (ABS(DIMENS-1) .LT. 0.1D0) THEN
        SIGMA_S(1) = SIGMA_S1R*COS(-PSI1)*COS(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2R*COS(-PSI2)*COS(-PSI2)*(AS2/HOEHE)
        SIGMA_S(2) = SIGMA_S1R*SIN(-PSI1)*SIN(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2R*SIN(-PSI2)*SIN(-PSI2)*(AS2/HOEHE)
        SIGMA_S(3) = SIGMA_S1R*(-SIN(-PSI1)*COS(-PSI1))*(AS1/HOEHE)+
     &               SIGMA_S2R*(-SIN(-PSI2)*COS(-PSI2))*(AS2/HOEHE)

      ELSE
        SIGMA_S(1) = SIGMA_S1R*COS(-PSI1)*COS(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2R*COS(-PSI2)*COS(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(2) = SIGMA_S1R*SIN(-PSI1)*SIN(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2R*SIN(-PSI2)*SIN(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(3) = SIGMA_S1R*(-SIN(-PSI1)*COS(-PSI1))*(AS1/DELTA_Z)+
     &               SIGMA_S2R*(-SIN(-PSI2)*COS(-PSI2))*(AS2/DELTA_Z)

      END IF

      ! SPANNUNGEN INFOLGE QUERKRAFT!

      STATUS_Q=INT(MATERIAL(56))

      IF (STATUS_Q.GT.0) THEN

        STATUS_Q=4 ! AUFRUF �BER CMM (MODELL 4)

        CALL SUB_ZQ(SCHICHTINFO,MATERIAL
     &             ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATUS_Q)

      ELSE

       SIGX_Q = CMPLX(0D0,0D0,KIND=8)
       SIGY_Q = CMPLX(0D0,0D0,KIND=8)
       TAUXY_Q = CMPLX(0D0,0D0,KIND=8)
       RHO_Z = CMPLX(0D0,0D0,KIND=8)
       STATUS_Q=10

      END IF

      ! SPANNUNGEN TOTAL:
      SPANNUNGEN(1) = SIGMA_C(1)+SIGMA_S(1)-SIGX_Q
      SPANNUNGEN(2) = SIGMA_C(2)+SIGMA_S(2)-SIGY_Q
      SPANNUNGEN(3) = SIGMA_C(3)+SIGMA_S(3)-TAUXY_Q

      ! AUSGABEWERTE:
      DRUCKFELD(1) = REAL(SIGMA_C3)
      DRUCKFELD(2) = REAL(FC)
      DRUCKFELD(3) = REAL(SIGMA_S1R)
      DRUCKFELD(4) = REAL(SIGMA_S2R)
      DRUCKFELD(5) = REAL(EPS1)
      DRUCKFELD(6) = REAL(EPS2)
      DRUCKFELD(7) = REAL(THETA)
      DRUCKFELD(8) = REAL(SRM1)
      DRUCKFELD(9) = REAL(SRM2)
      DRUCKFELD(10) = REAL(WCR1)
      DRUCKFELD(11) = REAL(WCR2)
      DRUCKFELD(12) = REAL(RHO_Z)

      END SUBROUTINE SUB_S_E_CMM

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER SPANNUNGEN IN FUNKTION DER
!     VERZERRUNGEN NACH EINEM MODELL F�R ZWEIACHSIGE ZUGBEANSPRUCHUNGEN
!
!   PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                       PATRICK ROOS, HOCHSCHULE LUZERN
!   DATUM:              03.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_ZUG(EX,EY,GAMMA_XY,DEPS,MATERIAL,SCHICHTINFO,
     &                       SPANNUNGEN,ZUG,STATE_ZUG)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
      DOUBLE PRECISION, DIMENSION(60), INTENT(IN) :: MATERIAL
      DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: DEPS
      INTEGER, INTENT(IN) :: SCHICHTINFO
      DOUBLE COMPLEX, DIMENSION(3), INTENT(OUT) :: SPANNUNGEN
      DOUBLE PRECISION, DIMENSION(11), INTENT(OUT) :: ZUG
      INTEGER, DIMENSION(2), INTENT(OUT) :: STATE_ZUG

      DOUBLE COMPLEX :: SIGMA_C1, SIGMA_C3, THETA, E1, E3
      DOUBLE COMPLEX, DIMENSION(3) :: SIGMA_C, SIGMA_S

      DOUBLE COMPLEX ::   N, HOEHE, CO, CU,
     &                    AS1, DM1, PSI1, FSY1, FSU1, ESU1, ESV1, ES1,
     &                    KA1, KB1, KC1,
     &                    AS2, DM2, PSI2, FSY2, FSU2, ESU2, ESV2, ES2,
     &                    KA2, KB2, KC2,
     &                    FCC, ECU, K_E, THETA_B0, THETA_B1, K_RISS,
     &                    LAMBDA, SRM1_VORGABE, SRM2_VORGABE
      DOUBLE COMPLEX ::   RHO1, RHO2, FCT, EC, DELTA_Z, HOEHE_FIKTIV,
     &                    C, ZS1, ZS2, ZO, SR10, SR20, PI,
     &                    SRM1, SRM2, SRM,
     &                    SIGMA_S1R, SIGMA_S2R, TAU_B0, TAU_B1,
     &                    WCR1, WCR2, EPS1, EPS2,
     &                    SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
      INTEGER :: STAHL1, STAHL2, ZM1, ZM2, DIMENS, BEGRENZUNG,STATUS_Q
      INTEGER, DIMENSION(2) :: BETON

      DOUBLE PRECISION, DIMENSION(5) :: D_THETA, D_PSI1, D_PSI2

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE

      SUBROUTINE SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)
        DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: THETA
      END SUBROUTINE SUB_THETA_ALLGEMEIN

      SUBROUTINE SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
        DOUBLE COMPLEX,  INTENT(IN) :: EX, EY, GAMMA_XY
        DOUBLE COMPLEX, INTENT(OUT) :: E1, E3
      END SUBROUTINE SUB_E1_E3

      SUBROUTINE SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1, E3, FCC, ECU, K_E
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_C3
      END SUBROUTINE SUB_S_E_BETON

      SUBROUTINE SUB_S_E_STAHL(STAHL,EPS,FSY,FSU,ESU,ESV,ES,KA,
     &                         KB,KC,SIGMA_S)
        INTEGER, INTENT(IN) :: STAHL
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL

      SUBROUTINE SUB_S_E_ZM(ZM,ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,
     &                      TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)
        INTEGER, INTENT(IN) :: ZM
        DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,
     &                                TAU_B0,TAU_B1,EC,RHO,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT):: SIGMA_SR
      END SUBROUTINE SUB_S_E_ZM

      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      SUBROUTINE SUB_ZQ(SCHICHTINFO,MATERIAL
     &                  ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATE)
        INTEGER,INTENT(IN)            :: SCHICHTINFO
        DOUBLE PRECISION,DIMENSION(60),INTENT(IN):: MATERIAL
        DOUBLE COMPLEX,INTENT(OUT)    :: SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
        INTEGER,INTENT(INOUT)         :: STATE
      END SUBROUTINE SUB_ZQ

      END INTERFACE

      ! VORGABEN:
      ZUG = 0D0
      STATE_ZUG = 0

      PI = CMPLX(4.0D0*ATAN(1.0D0),0D0,KIND=8)

      ! EINLESEN DER MATERIALKENNWERTE:
      ! ALLGEMEIN:
      DIMENS = MATERIAL(1)

      ! GEOMETRIE:
      N = CMPLX(MATERIAL(3),0D0,KIND=8)
      HOEHE = CMPLX(MATERIAL(4),0D0,KIND=8)
      CO = CMPLX(MATERIAL(5),0D0,KIND=8)
      CU = CMPLX(MATERIAL(6),0D0,KIND=8)

      ! BEWEHRUNG IN X-RICHTUNG:
      STAHL1 = MATERIAL(7)
      ZM1 = MATERIAL(8)
      AS1 = CMPLX(MATERIAL(9),0D0,KIND=8)
      DM1 = CMPLX(MATERIAL(10),0D0,KIND=8)
      PSI1 = CMPLX(MATERIAL(11),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY1 = CMPLX(MATERIAL(12),0D0,KIND=8)
      FSU1 = CMPLX(MATERIAL(13),0D0,KIND=8)
      ESU1 = CMPLX(MATERIAL(14),0D0,KIND=8)
      ESV1 = CMPLX(MATERIAL(15),0D0,KIND=8)
      ES1 = CMPLX(MATERIAL(16),0D0,KIND=8)
      KA1 = CMPLX(MATERIAL(17),0D0,KIND=8)
      KB1 = CMPLX(MATERIAL(18),0D0,KIND=8)
      KC1 = CMPLX(MATERIAL(19),0D0,KIND=8)

      ! BEWEHRUNG IN Y-RICHTUNG:
      STAHL2 = MATERIAL(20)
      ZM2 = MATERIAL(21)
      AS2 = CMPLX(MATERIAL(22),0D0,KIND=8)
      DM2 = CMPLX(MATERIAL(23),0D0,KIND=8)
      PSI2 = CMPLX(MATERIAL(24),0D0,KIND=8)*(PI/CMPLX(180D0,0D0,KIND=8))
      FSY2 = CMPLX(MATERIAL(25),0D0,KIND=8)
      FSU2 = CMPLX(MATERIAL(26),0D0,KIND=8)
      ESU2 = CMPLX(MATERIAL(27),0D0,KIND=8)
      ESV2 = CMPLX(MATERIAL(28),0D0,KIND=8)
      ES2 = CMPLX(MATERIAL(29),0D0,KIND=8)
      KA2 = CMPLX(MATERIAL(30),0D0,KIND=8)
      KB2 = CMPLX(MATERIAL(31),0D0,KIND=8)
      KC2 = CMPLX(MATERIAL(32),0D0,KIND=8)

      ! BER�CKSICHTIGUNG GENEIGTER BEWEHRUNG:
      D_PSI1(1) = REAL(ABS(ABS(REAL(PSI1))))                 ! PSI1 = 0
      D_PSI1(2) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI1(3) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)))        ! PSI1 = 180
      D_PSI1(4) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI1(5) = REAL(ABS(ABS(REAL(PSI1))-REAL(PI)*2D0))    ! PSI1 = 360

      D_PSI2(1) = REAL(ABS(ABS(REAL(PSI2))))                 ! PSI1 = 0
      D_PSI2(2) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)/2D0))    ! PSI1 = 90
      D_PSI2(3) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)))        ! PSI1 = 180
      D_PSI2(4) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*1.5D0))  ! PSI1 = 270
      D_PSI2(5) = REAL(ABS(ABS(REAL(PSI2))-REAL(PI)*2D0))    ! PSI1 = 360

      IF (MIN(D_PSI1(1),D_PSI1(2),D_PSI1(3),D_PSI1(4),D_PSI1(5))
     &   .LT. 1D-2) THEN
      ES1 = ES1
      ESU1 = ESU1
      ESV1 = ESV1
      ELSE
      ES1 = ES1 !COS(PSI1)*COS(PSI1)*ES1
      ESU1 = ESU1 !/(COS(PSI1)*COS(PSI1))
      ESV1 = ESV1 !/(COS(PSI1)*COS(PSI1))
      ENDIF

      IF (MIN(D_PSI2(1),D_PSI2(2),D_PSI2(3),D_PSI2(4),D_PSI2(5))
     &   .LT. 1D-2) THEN
      ES2 = ES2
      ESU2 = ESU2
      ESV2 = ESV2
      ELSE
      ES2=  ES2 !SIN(PSI2)*SIN(PSI2)*ES2
      ESU2 = ESU2 !/(SIN(PSI2)*SIN(PSI2))
      ESV2 = ESV2 !/(SIN(PSI2)*SIN(PSI2))
      ENDIF

      ! BETON:
      BETON(1) = MATERIAL(33)
      BETON(2) = MATERIAL(41)
      FCC = CMPLX(MATERIAL(34),0D0,KIND=8)
      ECU = CMPLX(MATERIAL(36),0D0,KIND=8)
      K_E = CMPLX(MATERIAL(37),0D0,KIND=8)
      THETA_B0 = CMPLX(MATERIAL(38),0D0,KIND=8)
      THETA_B1 = CMPLX(MATERIAL(39),0D0,KIND=8)
      K_RISS = CMPLX(MATERIAL(40),0D0,KIND=8)

      ! RISSABSTAND:
      LAMBDA = CMPLX(MATERIAL(42),0D0,KIND=8)
      SRM1_VORGABE = CMPLX(MATERIAL(43),0D0,KIND=8)
      SRM2_VORGABE = CMPLX(MATERIAL(44),0D0,KIND=8)
      BEGRENZUNG = MATERIAL(45)

      ! BERECHNUNGEN BETONKENNWERTE:
      EC = K_E*FCC**CMPLX((1D0/3D0),0D0,KIND=8)
      FCT = CMPLX(0.3D0,0D0,KIND=8)*(FCC*FCC)**
     &      CMPLX((1D0/3D0),0D0,KIND=8)

      TAU_B0 = THETA_B0*FCT
      TAU_B1 = THETA_B1*FCT

      ! BERECHNUNG DER FIKTIVEN SCHICHTH�HE
      DELTA_Z = HOEHE/N

      ! BERECHNUNG DER SCHICHTH�HEN
      IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 2) THEN
      ZS1 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CU-(DM1/CMPLX(2D0,0D0,KIND=8))
      ZS2 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CU-DM1-
     &       (DM2/CMPLX(2D0,0D0,KIND=8))
      ELSE IF (SCHICHTINFO .EQ. 3 .OR. SCHICHTINFO .EQ. 4) THEN
      ZS1 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CO-(DM1/CMPLX(2D0,0D0,KIND=8))
      ZS2 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-CO-DM1-
     &       (DM2/CMPLX(2D0,0D0,KIND=8))
      ELSE
      C = (CO+CU)/CMPLX(2D0,0D0,KIND=8)
      ZS1 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-C-(DM1/CMPLX(2D0,0D0,KIND=8))
      ZS2 = (HOEHE/CMPLX(2D0,0D0,KIND=8))-C-DM1-
     &       (DM2/CMPLX(2D0,0D0,KIND=8))
      END IF

      ZO = (ZS1+ZS2)/CMPLX(2D0,0D0,KIND=8)
      HOEHE_FIKTIV = ((HOEHE/CMPLX(2D0,0D0,KIND=8))-(ZO))*
     &               CMPLX(2D0,0D0,KIND=8)

        IF (REAL(HOEHE_FIKTIV) .GT. REAL(HOEHE/
     &      CMPLX(2D0,0D0,KIND=8))) THEN
            HOEHE_FIKTIV = HOEHE/CMPLX(2D0,0D0,KIND=8)
        END IF

      IF (ABS(DIMENS-1) .LT. 0.1D0 .OR. ABS(REAL(N)-1D0) .LT. 0.1D0)
     &   THEN
         RHO1 = AS1/(HOEHE_FIKTIV*CMPLX(2D0,0D0,KIND=8))
         RHO2 = AS2/(HOEHE_FIKTIV*CMPLX(2D0,0D0,KIND=8))
      ELSE
         RHO1 = AS1/(HOEHE_FIKTIV)
         RHO2 = AS2/(HOEHE_FIKTIV)
      END IF

      ! MAXIMALE RISSABST�NDE
      SR10 = (DM1*FCT*(CMPLX(1D0,0D0,KIND=8)-RHO1))/
     &       (CMPLX(2D0,0D0,KIND=8)*TAU_B0*RHO1)
      SR20 = (DM2*FCT*(CMPLX(1D0,0D0,KIND=8)-RHO2))/
     &       (CMPLX(2D0,0D0,KIND=8)*TAU_B0*RHO2)

      ! HAUPTVERZERRUNGEN:
      CALL SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)
      CALL SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)

      ! KONTROLLE THETA
      D_THETA(1) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)/2D0))
      D_THETA(2) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*1.5D0))
      D_THETA(3) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)))
      D_THETA(4) = REAL(ABS(ABS(REAL(THETA))-REAL(PI)*2D0))
      D_THETA(5) = REAL(ABS(REAL(THETA)))


      ! FALLUNTERSCHEIDUNG (FALL 1):
      IF (0D0 .LE. REAL(E3) .AND. REAL(E3) .LE. REAL((FCT*K_RISS)/EC))
     &THEN

        ! BETONSPANNUNGEN:
        SIGMA_C1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_C3 = E3*EC

        SIGMA_C(1) = SIGMA_C1*COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &               COS(THETA)*COS(THETA)
        SIGMA_C(2) = SIGMA_C1*SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) + SIGMA_C3*
     &               SIN(THETA)*SIN(THETA)
        SIGMA_C(3) = SIGMA_C1*(-SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))) + SIGMA_C3*
     &               (-SIN(THETA)*COS(THETA))


        ! VERZERRUNGEN IN BEWEHRUNGSRICHTUNG:
        IF (MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN
        EPS1 = EX
        ELSE IF (MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2) THEN
        EPS1 = EY
        ELSE
        EPS1 = EX*COS(-PSI1)*COS(-PSI1)+EY*SIN(-PSI1)*SIN(-PSI1)+
     &         GAMMA_XY*(-SIN(-PSI1)*COS(-PSI1))
        END IF

        IF (MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2 ) THEN
        EPS2 = EY
        ELSE IF (MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2 ) THEN
        EPS2 = EX
        ELSE
        EPS2 = EX*COS(-PSI2)*COS(-PSI2)+EY*SIN(-PSI2)*SIN(-PSI2)+
     &         GAMMA_XY*(-SIN(-PSI2)*COS(-PSI2))
        END IF

        SRM = LAMBDA/((ABS_C(SIN(THETA+PSI1))/SR10)+
     &        (ABS_C(SIN(THETA+PSI2))/SR20))

        ! FESTLEGUNG DER RISSABST�NDE:
        IF (MIN(D_THETA(3),D_THETA(4),D_THETA(5)) .LT. 1D-2
     &     .AND. MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN

          SRM1 = CMPLX(0D0,0D0,KIND=8)
          SRM2 = SRM/ABS_C(SIN(THETA+PSI2))

          IF (ABS(BEGRENZUNG - 1D0) .LT. 0.1D0) THEN
            IF (REAL(SRM2) .GT. REAL(LAMBDA*SR20)) THEN
              SRM2 = LAMBDA * SR20
            END IF
          END IF

          IF (ABS(REAL(SRM2_VORGABE)-1D0) .LT. 0.1D0) THEN
            SRM2 = SRM2
          ELSE
            SRM2 = SRM2_VORGABE
          END IF

          IF (REAL(DM1) .GT. 0.1D0) THEN
            CALL SUB_S_E_STAHL(STAHL1,EPS1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                         KA1,KB1,KC1,SIGMA_S1R)
          ELSE
            SIGMA_S1R = CMPLX(0D0,0D0,KIND=8)
          END IF

          CALL SUB_S_E_ZM(ZM2,EPS2,SRM2,DM2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                    TAU_B0,TAU_B1,EC,RHO2,KA2,KB2,KC2,SIGMA_S2R)

       ELSE IF (MIN(D_THETA(3),D_THETA(4),D_THETA(5)) .LT. 1D-2
     &     .AND. MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2) THEN

          SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
          SRM2 = CMPLX(0D0,0D0,KIND=8)

          IF (ABS(BEGRENZUNG - 1D0) .LT. 0.1D0) THEN
            IF (REAL(SRM1) .GT. REAL(LAMBDA*SR10)) THEN
              SRM1 = LAMBDA * SR10
            END IF
          END IF

          IF (ABS(REAL(SRM1_VORGABE)-1D0) .LT. 0.1D0) THEN
            SRM1 = SRM1
          ELSE
            SRM1 = SRM1_VORGABE
          END IF

          IF (REAL(DM2) .GT. 0.1D0) THEN
            CALL SUB_S_E_STAHL(STAHL2,EPS2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                         KA2,KB2,KC2,SIGMA_S2R)
          ELSE
            SIGMA_S2R = CMPLX(0D0,0D0,KIND=8)
          END IF

          CALL SUB_S_E_ZM(ZM1,EPS1,SRM1,DM1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                    TAU_B0,TAU_B1,EC,RHO1,KA1,KB1,KC1,SIGMA_S1R)


        ELSE IF (MIN(D_THETA(1),D_THETA(2)) .LT. 1D-2
     &           .AND. MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2 ) THEN

          SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
          SRM2 = CMPLX(0D0,0D0,KIND=8)

          IF (ABS(BEGRENZUNG - 1D0) .LT. 0.1D0) THEN
            IF (REAL(SRM1) .GT. REAL(LAMBDA*SR10)) THEN
              SRM1 = LAMBDA * SR10
            END IF
          END IF

          IF (ABS(REAL(SRM1_VORGABE)-1D0) .LT. 0.1D0) THEN
            SRM1 = SRM1
          ELSE
            SRM1 = SRM1_VORGABE
          END IF

          CALL SUB_S_E_ZM(ZM1,EPS1,SRM1,DM1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                    TAU_B0,TAU_B1,EC,RHO1,KA1,KB1,KC1,SIGMA_S1R)
          IF (REAL(DM2) .GT. 0.1D0) THEN
            CALL SUB_S_E_STAHL(STAHL2,EPS2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                         KA2,KB2,KC2,SIGMA_S2R)
          ELSE
            SIGMA_S2R = CMPLX(0D0,0D0,KIND=8)
          END IF

        ELSE IF (MIN(D_THETA(1),D_THETA(2)) .LT. 1D-2
     &           .AND. MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2 ) THEN

          SRM1 = CMPLX(0D0,0D0,KIND=8)
          SRM2 = SRM/ABS_C(SIN(THETA+PSI2))

          IF (ABS(BEGRENZUNG - 1D0) .LT. 0.1D0) THEN
            IF (REAL(SRM2) .GT. REAL(LAMBDA*SR20)) THEN
              SRM2 = LAMBDA * SR20
            END IF
          END IF

          IF (ABS(REAL(SRM2_VORGABE)-1D0) .LT. 0.1D0) THEN
            SRM2 = SRM2
          ELSE
            SRM2 = SRM2_VORGABE
          END IF

          CALL SUB_S_E_ZM(ZM2,EPS2,SRM2,DM2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                    TAU_B0,TAU_B1,EC,RHO2,KA2,KB2,KC2,SIGMA_S2R)
          IF (REAL(DM1) .GT. 0.1D0) THEN
            CALL SUB_S_E_STAHL(STAHL1,EPS1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                         KA1,KB1,KC1,SIGMA_S1R)
          ELSE
            SIGMA_S1R = CMPLX(0D0,0D0,KIND=8)
          END IF

        ELSE
          SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
          SRM2 = SRM/ABS_C(SIN(THETA+PSI2))


          IF (ABS(BEGRENZUNG-1D0) .LT. 0.1D0) THEN
            IF (REAL(SRM1) .GT. REAL(LAMBDA*SR10)) THEN
              SRM1 = LAMBDA * SR10
            END IF
            IF (REAL(SRM2) .GT. REAL(LAMBDA*SR20)) THEN
              SRM2 = LAMBDA * SR20
            END IF
          END IF

          IF (ABS(REAL(SRM1_VORGABE)-1D0) .LT. 0.1D0) THEN
            SRM1 = SRM1
          ELSE
            SRM1 = SRM1_VORGABE
          END IF

          IF (ABS(REAL(SRM2_VORGABE)-1D0) .LT. 0.1D0) THEN
            SRM2 = SRM2
          ELSE
            SRM2 = SRM2_VORGABE
          END IF

          CALL SUB_S_E_ZM(ZM1,EPS1,SRM1,DM1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                    TAU_B0,TAU_B1,EC,RHO1,KA1,KB1,KC1,SIGMA_S1R)
          CALL SUB_S_E_ZM(ZM2,EPS2,SRM2,DM2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                    TAU_B0,TAU_B1,EC,RHO2,KA2,KB2,KC2,SIGMA_S2R)
        END IF

        IF (REAL(DM1) .GT. 0.1D0) THEN
        SRM1 = SRM1
        ELSE
        SRM1 = CMPLX(0D0,0D0,KIND=8)
        END IF

        IF (REAL(DM2) .GT. 0.1D0) THEN
        SRM2 = SRM2
        ELSE
        SRM2 = CMPLX(0D0,0D0,KIND=8)
        END IF

      ! UNTERSCHEIDUNG 2D / 3D

      IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 4) THEN
        AS2 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S2R = CMPLX(0D0,0D0,KIND=8)
      ELSE IF (SCHICHTINFO .EQ. 2 .OR. SCHICHTINFO .EQ. 3) THEN
        AS1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S1R = CMPLX(0D0,0D0,KIND=8)
      END IF

      IF (ABS(DIMENS-1) .LT. 0.1D0) THEN
        SIGMA_S(1) = SIGMA_S1R*COS(-PSI1)*COS(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2R*COS(-PSI2)*COS(-PSI2)*(AS2/HOEHE)
        SIGMA_S(2) = SIGMA_S1R*SIN(-PSI1)*SIN(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2R*SIN(-PSI2)*SIN(-PSI2)*(AS2/HOEHE)
        SIGMA_S(3) = SIGMA_S1R*(-SIN(-PSI1)*COS(-PSI1))*(AS1/HOEHE)+
     &               SIGMA_S2R*(-SIN(-PSI2)*COS(-PSI2))*(AS2/HOEHE)

      ELSE
        SIGMA_S(1) = SIGMA_S1R*COS(-PSI1)*COS(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2R*COS(-PSI2)*COS(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(2) = SIGMA_S1R*SIN(-PSI1)*SIN(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2R*SIN(-PSI2)*SIN(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(3) = SIGMA_S1R*(-SIN(-PSI1)*COS(-PSI1))*(AS1/DELTA_Z)+
     &               SIGMA_S2R*(-SIN(-PSI2)*COS(-PSI2))*(AS2/DELTA_Z)

      END IF

        ! BERECHNUNG DER RISSWEITEN:
        WCR1 = EPS1*SRM1
        WCR2 = EPS2*SRM2

        ! SPANNUNGEN TOTAL:
        SPANNUNGEN(1) = SIGMA_C(1)+SIGMA_S(1)
        SPANNUNGEN(2) = SIGMA_C(2)+SIGMA_S(2)
        SPANNUNGEN(3) = GAMMA_XY*100D0


      !FALLUNTERSCHEIDUNG (FALL 2):
      ELSE IF (REAL(E3) .GT. REAL((FCT*K_RISS)/EC)) THEN

        ! BETONSPANNUNGEN:
        SIGMA_C1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)

!        SIGMA_C(1) = SIGMA_C1*COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
!     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) +
!     &               SIGMA_C3*COS(THETA)*COS(THETA)
!        SIGMA_C(2) = SIGMA_C1*SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
!     &               SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8))) +
!     &               SIGMA_C3*SIN(THETA)*SIN(THETA)
!        SIGMA_C(3) = SIGMA_C1*(-SIN(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))*
!     &               COS(THETA-(PI/CMPLX(2D0,0D0,KIND=8)))) +
!     &               SIGMA_C3*(-SIN(THETA)*COS(THETA))

        SIGMA_C(1) = EX*CMPLX(1D-3,0D0,KIND=8)
        SIGMA_C(2) = EY*CMPLX(1D-3,0D0,KIND=8)
        SIGMA_C(3) = GAMMA_XY*CMPLX(1D-3,0D0,KIND=8)

        ! VERZERRUNGEN IN BEWEHRUNGSRICHTUNG:
        IF (MIN(D_PSI1(1),D_PSI1(3),D_PSI1(5)) .LT. 1D-2) THEN
        EPS1 = EX
        ELSE IF (MIN(D_PSI1(2),D_PSI1(4)) .LT. 1D-2) THEN
        EPS1 = EY
        ELSE
        EPS1 = EX*COS(-PSI1)*COS(-PSI1)+EY*SIN(-PSI1)*SIN(-PSI1)+
     &         GAMMA_XY*(-SIN(-PSI1)*COS(-PSI1))
        END IF

        IF (MIN(D_PSI2(2),D_PSI2(4)) .LT. 1D-2 ) THEN
        EPS2 = EY
        ELSE IF (MIN(D_PSI2(1),D_PSI2(3),D_PSI2(5)) .LT. 1D-2 ) THEN
        EPS2 = EX
        ELSE
        EPS2 = EX*COS(-PSI2)*COS(-PSI2)+EY*SIN(-PSI2)*SIN(-PSI2)+
     &         GAMMA_XY*(-SIN(-PSI2)*COS(-PSI2))
        END IF

        SRM = LAMBDA/((ABS_C(SIN(THETA+PSI1))/SR10)+
     &        (ABS_C(SIN(THETA+PSI2))/SR20))


        ! FESTLEGUNG DER RISSABST�NDE:
        IF (MIN(D_PSI1(1),D_PSI1(2),D_PSI1(3),D_PSI1(4),D_PSI1(5))
     &  .LT. 1D-2 ) THEN
          SRM1 = LAMBDA*SR10
        ELSE
          SRM1 = SRM/ABS_C(SIN(THETA+PSI1))
        END IF


        IF (MIN(D_PSI2(1),D_PSI2(2),D_PSI2(3),D_PSI2(4),D_PSI2(5))
     &  .LT. 1D-2 ) THEN
          SRM2 = LAMBDA*SR20
        ELSE
          SRM2 = SRM/ABS_C(SIN(THETA+PSI2))
        END IF

        ! BEGRENZUNG DER RISSABST�NDE:
        IF (ABS(BEGRENZUNG-1D0) .LT. 0.1D0) THEN
          IF (REAL(SRM1) .GT. REAL(LAMBDA*SR10)) THEN
            SRM1 = LAMBDA*SR10
          END IF
          IF (REAL(SRM2) .GT. REAL(LAMBDA*SR20)) THEN
            SRM2 = LAMBDA*SR20
          END IF
        END IF

        ! VERWENDUNG VON VORGABEN:
        IF (ABS(REAL(SRM1_VORGABE)-1D0) .LT. 0.1D0) THEN
          SRM1 = SRM1
        ELSE
          SRM1 = SRM1_VORGABE
        END IF

        IF (ABS(REAL(SRM2_VORGABE)-1D0) .LT. 0.1D0) THEN
          SRM2 = SRM2
        ELSE
          SRM2 = SRM2_VORGABE
        END IF

        ! ELIMINIERUNG SRM WENN KEINE BEWEHRUNG VORHANDEN.
        IF (REAL(DM1) .GT. 0.1D0) THEN
          SRM1 = SRM1
        ELSE
          SRM1 = CMPLX(0D0,0D0,KIND=8)
        END IF

        IF (REAL(DM2) .GT. 0.1D0) THEN
          SRM2 = SRM2
        ELSE
          SRM2 = CMPLX(0D0,0D0,KIND=8)
        END IF

        ! BERECHNUNG DER STAHLSPANNUNGEN AM RISS
        CALL SUB_S_E_ZM(ZM1,EPS1,SRM1,DM1,FSY1,FSU1,ESU1,ESV1,ES1,
     &                  TAU_B0,TAU_B1,EC,RHO1,KA1,KB1,KC1,SIGMA_S1R)
        CALL SUB_S_E_ZM(ZM2,EPS2,SRM2,DM2,FSY2,FSU2,ESU2,ESV2,ES2,
     &                  TAU_B0,TAU_B1,EC,RHO2,KA2,KB2,KC2,SIGMA_S2R)

        ! UNTERSCHEIDUNG 2D / 3D

        IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 4) THEN
        AS2 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S2R = CMPLX(0D0,0D0,KIND=8)
        ELSE IF (SCHICHTINFO .EQ. 2 .OR. SCHICHTINFO .EQ. 3) THEN
        AS1 = CMPLX(0D0,0D0,KIND=8)
        SIGMA_S1R = CMPLX(0D0,0D0,KIND=8)
        END IF

        IF (ABS(DIMENS-1) .LT. 0.1D0) THEN
        SIGMA_S(1) = SIGMA_S1R*COS(-PSI1)*COS(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2R*COS(-PSI2)*COS(-PSI2)*(AS2/HOEHE)
        SIGMA_S(2) = SIGMA_S1R*SIN(-PSI1)*SIN(-PSI1)*(AS1/HOEHE)+
     &               SIGMA_S2R*SIN(-PSI2)*SIN(-PSI2)*(AS2/HOEHE)
        SIGMA_S(3) = SIGMA_S1R*(-SIN(-PSI1)*COS(-PSI1))*(AS1/HOEHE)+
     &               SIGMA_S2R*(-SIN(-PSI2)*COS(-PSI2))*(AS2/HOEHE)

        ELSE
        SIGMA_S(1) = SIGMA_S1R*COS(-PSI1)*COS(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2R*COS(-PSI2)*COS(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(2) = SIGMA_S1R*SIN(-PSI1)*SIN(-PSI1)*(AS1/DELTA_Z)+
     &               SIGMA_S2R*SIN(-PSI2)*SIN(-PSI2)*(AS2/DELTA_Z)
        SIGMA_S(3) = SIGMA_S1R*(-SIN(-PSI1)*COS(-PSI1))*(AS1/DELTA_Z)+
     &               SIGMA_S2R*(-SIN(-PSI2)*COS(-PSI2))*(AS2/DELTA_Z)

        END IF

        ! BERECHNUNG DER RISSWEITEN:
        WCR1 = EPS1*SRM1
        WCR2 = EPS2*SRM2

        ! SPANNUNGEN TOTAL:
        SPANNUNGEN(1) = SIGMA_C(1)+SIGMA_S(1)
        SPANNUNGEN(2) = SIGMA_C(2)+SIGMA_S(2)
        SPANNUNGEN(3) = GAMMA_XY*100D0

      ELSE

        SPANNUNGEN(1) = EX*CMPLX(1D-6,0D0,KIND=8)
        SPANNUNGEN(2) = EY*CMPLX(1D-6,0D0,KIND=8)
        SPANNUNGEN(3) = GAMMA_XY*CMPLX(1D-6,0D0,KIND=8)

      END IF

      ! SPANNUNGEN INFOLGE QUERKRAFT!

      STATUS_Q=MATERIAL(56)

      IF (STATUS_Q.GT.0) THEN

        STATUS_Q=5 ! AUFRUF �BER CMM (MODELL 4)

        CALL SUB_ZQ(SCHICHTINFO,MATERIAL
     &             ,SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATUS_Q)

        SPANNUNGEN(1) = SPANNUNGEN(1)+SIGX_Q
        SPANNUNGEN(2) = SPANNUNGEN(2)+SIGY_Q
        SPANNUNGEN(3) = SPANNUNGEN(3)+TAUXY_Q

      ELSE
       STATUS_Q=10
      END IF

      ! ZUSTAND DER BEWEHRUNGEN
      IF (ABS(REAL(SIGMA_S1R)) >= REAL(FSY1) .AND. ABS(REAL(SIGMA_S1R))
     &    .LT. REAL(FSU1)) THEN
          !PRINT *, 'BEWEHRUNG IN X-RICHTUNG AM FLIESSEN!'
          STATE_ZUG(1) = 1
      ELSE IF (ABS(REAL(SIGMA_S1R)) >= REAL(FSU1)) THEN
          !PRINT *, 'BEWEHRUNG IN X-RICHTUNG GERISSEN!'
          STATE_ZUG(1) = 2
      END IF

      IF (ABS(REAL(SIGMA_S2R)) >= REAL(FSY2) .AND. ABS(REAL(SIGMA_S2R))
     &    .LT. REAL(FSU2)) THEN
          !PRINT *, 'BEWEHRUNG IN Y-RICHTUNG AM FLIESSEN!'
          STATE_ZUG(2) = 1
      ELSE IF (ABS(REAL(SIGMA_S2R)) >= REAL(FSU2)) THEN
          !PRINT *, 'BEWEHRUNG IN Y-RICHTUNG GERISSEN!'
          STATE_ZUG(2) = 2
      END IF

      ! AUSGABEWERTE:
      ZUG(1) = REAL(SIGMA_C1)
      ZUG(2) = REAL(SIGMA_S1R)
      ZUG(3) = REAL(SIGMA_S2R)
      ZUG(4) = REAL(EPS1)
      ZUG(5) = REAL(EPS2)
      ZUG(6) = REAL(THETA)
      ZUG(7) = REAL(SRM1)
      ZUG(8) = REAL(SRM2)
      ZUG(9) = REAL(WCR1)
      ZUG(10) = REAL(WCR2)
      ZUG(11) = REAL(RHO_Z)

      END SUBROUTINE SUB_S_E_ZUG

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER BETONHAUPTDRUCKSPANNUNG IN FUNKTION
!     DER HAUPTVERZERRUNGEN F�R EIN BELIEBIGES WERKSTOFFGESETZ
!     (SARGIN, KAUFMANN....)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_BETON(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER, DIMENSION(2), INTENT(IN) :: BETON
      DOUBLE COMPLEX, INTENT(IN) :: E1, E3, FCC, ECU, K_E
      DOUBLE COMPLEX, INTENT(OUT):: SIGMA_C3

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE
        SUBROUTINE SUB_S_E_CS_SARGIN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1,E3,FCC,ECU,K_E
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_C3
        END SUBROUTINE SUB_S_E_CS_SARGIN

        SUBROUTINE SUB_S_E_CS_KAUFMANN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1,E3,FCC,ECU,K_E
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_C3
        END SUBROUTINE SUB_S_E_CS_KAUFMANN

        SUBROUTINE SUB_S_E_CC_SARGIN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)
        INTEGER, DIMENSION(2), INTENT(IN) :: BETON
        DOUBLE COMPLEX, INTENT(IN) :: E1,E3,FCC,ECU,K_E
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_C3
        END SUBROUTINE SUB_S_E_CC_SARGIN
      END INTERFACE

      ! UNTERSCHEIDUNG WERKSTOFFGESETZE

      IF (ABS(BETON(1)-1.0D0) .LT. 0.1D0) THEN

      CALL SUB_S_E_CS_SARGIN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      ELSEIF (ABS(BETON(1)-1.0D0) .LT. 1.1D0) THEN

      CALL SUB_S_E_CS_KAUFMANN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      ELSEIF (ABS(BETON(1)-1.0D0) .LT. 2.1D0) THEN

      CALL SUB_S_E_CC_SARGIN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      END IF

      ! KANN BELIEBIG ERWEITERT WERDEN, Z.B.:

      ! ELSEIF (ABS(BETON(1)-1.0D0) .LT. 3.1D0) THEN

      ! CALL SUB_S_E_CH_SARGIN(E1,E3,FCC,ECU,K_E,SIGMA_C3)

      ! END IF

      END SUBROUTINE SUB_S_E_BETON


!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER BETONHAUPTDRUCKSPANNUNGEN NACH
!      SARGIN (CS = CONCRETE SOFTENING)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_CS_SARGIN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER, DIMENSION(2), INTENT(IN) :: BETON
      DOUBLE COMPLEX, INTENT(IN)  :: E3, E1, FCC, ECU, K_E
      DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_C3
      DOUBLE COMPLEX   :: E31, ECU1, KS, FC, DIFF, ECU_95, EC, K


      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION MIN_RC(VAL1,VAL2)
        DOUBLE COMPLEX :: MIN_RC
        DOUBLE COMPLEX, INTENT(IN) :: VAL1, VAL2
      END FUNCTION MIN_RC
      END INTERFACE

      ! VERFESTIGENDES WERKSTOFFGESETZ
      K = CMPLX(0.95D0,0D0,KIND=8)

      ! ELASTIZIT�TSMODUL
      EC = K_E*ABS_C(FCC)**CMPLX(1D0/3D0,0D0,KIND=8)

      ! BERECHNUNG DER BETONHAUPTDRUCKSPANNUNG
      IF (REAL(E3) > 0D0) THEN

        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)

      ELSE IF ((REAL(E3) .LT. REAL(ECU)) .AND. ((2D0-BETON(2))
     &        .LT. 1.10D0)) THEN

        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)

      ELSE
        IF (REAL(E3) .LE. 0D0 .AND. REAL(E3) .GE. REAL(ECU)) THEN

          ECU1 = ABS_C(ECU)
          E31 = ABS_C(E3)
          FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &         CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &         CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &         CMPLX(30D0,0D0,KIND=8)*E1)))
          KS = (EC*ECU1)/FC
          SIGMA_C3 = -FC*((KS*(E31/ECU1)-((E31/ECU1)*(E31/ECU1)))/
     &               (CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))*
     &               (E31/ECU1)))

        ELSE

          ECU1 = ABS_C(ECU)
          ECU_95 = K*ECU1
          E31 = ABS_C(E3)
          FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &         CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &         CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &         CMPLX(30D0,0D0,KIND=8)*E1)))
          KS = (EC*ECU1)/FC
          DIFF = (KS/ECU1-CMPLX(2D0,0D0,KIND=8)*ECU_95/(ECU*ECU))/
     &           (CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))*
     &           ECU_95/ECU1)-(KS*ECU_95/ECU1-(ECU_95*ECU_95)/
     &           (ECU1*ECU1))*(KS-CMPLX(2D0,0D0,KIND=8))/
     &           ((CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))
     &           *ECU_95/ECU1)*(CMPLX(1D0,0D0,KIND=8)+
     &           (KS-CMPLX(2D0,0D0,KIND=8))*ECU_95/ECU1)*ECU1)
          SIGMA_C3 = -FC*(((KS*(ECU1/ECU1)-(ECU1/ECU1)*(ECU1/ECU1))/
     &               (CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))*
     &               (ECU1/ECU1))))+DIFF*(ECU1)-DIFF*(E31)

        END IF
      END IF

      END SUBROUTINE SUB_S_E_CS_SARGIN

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER BETONHAUPTDRUCKSPANNUNGEN NACH
!     KAUFMANN (CS = CONCRETE SOFTENING)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_CS_KAUFMANN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER, DIMENSION(2), INTENT(IN) :: BETON
      DOUBLE COMPLEX, INTENT(IN) :: E1, E3, FCC, ECU, K_E
      DOUBLE COMPLEX, INTENT(OUT):: SIGMA_C3
      DOUBLE COMPLEX :: FC, K, VAL, ECU_95, DIFF

      ! INTERFACES ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION MIN_RC(VAL1,VAL2)
        DOUBLE COMPLEX :: MIN_RC
        DOUBLE COMPLEX, INTENT(IN) :: VAL1, VAL2
      END FUNCTION MIN_RC
      END INTERFACE

      ! VERFESTIGENDES WERKSTOFFGESETZ
      K = CMPLX(0.95D0,0D0,KIND=8)
      ECU_95 = K*ECU

      ! BERECHNUNG DER BETONHAUPTDRUCKSPANNUNG
      IF (REAL(E3) .GT. 0D0) THEN
        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)

      ELSE IF ((REAL(E3) .LT. REAL(ECU)) .AND. ((2D0-BETON(2))
     &        .LT. 1.1D0)) THEN
        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)

      ELSE IF (REAL(E3) .LE. 0D0 .AND. REAL(E3) .GE. REAL(ECU_95)) THEN
        VAL = (FCC*FCC)**CMPLX(1D0/3D0,0D0,KIND=8)/
     &        (CMPLX(0.4D0,0D0,KIND=8)+CMPLX(30D0,0D0,KIND=8)*E1)
        VAL = ABS_C(VAL)
        FC = MIN_RC(FCC,VAL)
        SIGMA_C3 = FC*((E3*E3)+(CMPLX(2D0,0D0,KIND=8)*E3*ABS_C(ECU)))/
     &             (ECU*ECU)
      ELSE
        VAL = (FCC*FCC)**CMPLX(1D0/3D0,0D0,KIND=8)/
     &        (CMPLX(0.4D0,0D0,KIND=8)+CMPLX(30D0,0D0,KIND=8)*E1)
        VAL = ABS_C(VAL)
        FC = MIN_RC(FCC,VAL)
        DIFF = -FC*((2*ECU_95)+(CMPLX(2D0,0D0,KIND=8)*ABS_C(ECU)))/
     &         (ECU*ECU)
        SIGMA_C3 = FC*((ECU_95*ECU_95)+CMPLX(2D0,0D0,KIND=8)*ECU_95*
     &             ABS_C(ECU))/(ECU*ECU)+DIFF*(ECU_95-E3)
      END IF

      END SUBROUTINE SUB_S_E_CS_KAUFMANN

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER BETONHAUPTDRUCKSPANNUNGEN NACH
!      SARGIN (CC = CONCRETE CONSTANT)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_CC_SARGIN(BETON,E1,E3,FCC,ECU,K_E,SIGMA_C3)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER, DIMENSION(2), INTENT(IN) :: BETON
      DOUBLE COMPLEX, INTENT(IN)  :: E3, E1, FCC, ECU, K_E
      DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_C3
      DOUBLE COMPLEX   :: E31, ECU1, KS, FC, DIFF, ECU_95, EC, K, E11


      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION MIN_RC(VAL1,VAL2)
        DOUBLE COMPLEX :: MIN_RC
        DOUBLE COMPLEX, INTENT(IN) :: VAL1, VAL2
      END FUNCTION MIN_RC
      END INTERFACE

      ! VERFESTIGENDES WERKSTOFFGESETZ
      K = CMPLX(0.95D0,0D0,KIND=8)

      ! ELASTIZIT�TSMODUL
      EC = K_E*ABS_C(FCC)**CMPLX(1D0/3D0,0D0,KIND=8)
      E11 = CMPLX(0D0,0D0,KIND=8)

      ! BERECHNUNG DER BETONHAUPTDRUCKSPANNUNG
      IF (REAL(E3) .GT. 0D0) THEN

        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)

      ELSE IF ((REAL(E3) .LT. REAL(ECU)) .AND. ((2D0-BETON(2))
     &         .LT. 1.1D0)) THEN

        SIGMA_C3 = CMPLX(0D0,0D0,KIND=8)
      ELSE
        IF (REAL(E3) .LE. 0D0 .AND. REAL(E3) .GE. REAL(ECU)) THEN

          ECU1 = ABS_C(ECU)
          E31 = ABS_C(E3)
          FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &         CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &         CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &         CMPLX(30D0,0D0,KIND=8)*E11)))
          KS = ABS_C((EC*ECU1)/FC)
          SIGMA_C3 = -FC*((KS*(E31/ECU1)-((E31/ECU1)*(E31/ECU1)))/
     &               (CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))*
     &               (E31/ECU1)))

        ELSE

          ECU1 = ABS_C(ECU)
          ECU_95 = K*ECU1
          E31 = ABS_C(E3)
          FC = MIN_RC(ABS_C((FCC**CMPLX(2D0/3D0,0D0,KIND=8)/
     &         CMPLX(0.4D0,0D0,KIND=8))),ABS_C(FCC**
     &         CMPLX(2D0/3D0,0D0,KIND=8)/(CMPLX(0.4D0,0D0,KIND=8)+
     &         CMPLX(30D0,0D0,KIND=8)*E11)))
          KS = ABS_C((EC*ECU1)/FC)
          DIFF = (KS/ECU1-CMPLX(2D0,0D0,KIND=8)*ECU_95/(ECU*ECU))/
     &           (CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))*
     &           ECU_95/ECU1)-(KS*ECU_95/ECU1-(ECU_95*ECU_95)/
     &           (ECU1*ECU1))*(KS-CMPLX(2D0,0D0,KIND=8))/
     &           ((CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))
     &           *ECU_95/ECU1)*(CMPLX(1D0,0D0,KIND=8)+
     &           (KS-CMPLX(2D0,0D0,KIND=8))*ECU_95/ECU1)*ECU1)
          SIGMA_C3 = -FC*(((KS*(ECU1/ECU1)-(ECU1/ECU1)*(ECU1/ECU1))/
     &               (CMPLX(1D0,0D0,KIND=8)+(KS-CMPLX(2D0,0D0,KIND=8))*
     &               (ECU1/ECU1))))+DIFF*(ECU1)-DIFF*(E31)

        END IF
      END IF

      END SUBROUTINE SUB_S_E_CC_SARGIN

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER STAHLSPANNUNG IN FUNKTION DER
!     DEHNUNG F�R EIN BELIEBIGES WERKSTOFFGESETZ (BILINEAR,
!     KALTVERFORMT, WARMVERFORMT(NATURHART), TRILINEAR....)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_STAHL(STAHL,EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,
     &                         SIGMA_S)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER, INTENT(IN) :: STAHL
      DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
      DOUBLE COMPLEX, INTENT(OUT):: SIGMA_S

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE
      SUBROUTINE SUB_S_E_STAHL_BL(EPS,FSY,FSU,ESU,ES,SIGMA_S)
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ES
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL_BL

      SUBROUTINE SUB_S_E_STAHL_KV(EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,
     &                            SIGMA_S)
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL_KV

      SUBROUTINE SUB_S_E_STAHL_WV(EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,
     &                            SIGMA_S)
        DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_S
      END SUBROUTINE SUB_S_E_STAHL_WV
      END INTERFACE

      ! UNTERSCHEIDUNG WERKSTOFFGESETZE
      IF (ABS(STAHL-1.0D0) .LT. 0.1D0) THEN

        CALL SUB_S_E_STAHL_BL(EPS,FSY,FSU,ESU,ES,SIGMA_S)

      ELSEIF (ABS(STAHL-1.0D0) .LT. 1.1D0) THEN

        CALL SUB_S_E_STAHL_KV(EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,SIGMA_S)

      ELSEIF (ABS(STAHL-1.0D0) .LT. 2.1D0) THEN

        CALL SUB_S_E_STAHL_WV(EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,SIGMA_S)

      END IF

      ! KANN BELIEBIG ERWEITERT WERDEN, Z.B.:

      ! ELSEIF (ABS(STAHL-1.0D0) .LT. 3.1D0) THEN

      ! CALL SUB_S_E_STAHL_TL(EPS,FSY,FSU,ESU,ESV,ES,SIGMA_S)

      ! END IF

      END SUBROUTINE SUB_S_E_STAHL

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER STAHLSPANNUNGEN NACH EINEM
!     BILINEAREN STAHLSTOFFGESETZ
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_STAHL_BL(EPS,FSY,FSU,ESU,ES,SIGMA_S)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)      :: EPS, FSY, FSU, ESU, ES
      DOUBLE COMPLEX, INTENT(OUT)     :: SIGMA_S

      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION SIGN_RC(VAL1,VAL2)
        DOUBLE COMPLEX               :: SIGN_RC
        DOUBLE PRECISION, INTENT(IN) :: VAL1
        DOUBLE COMPLEX  , INTENT(IN) :: VAL2
      END FUNCTION SIGN_RC

      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX             :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C
      END INTERFACE

      ! BERECHNUNG DER STAHLSPANNUNG
      IF (REAL(-FSY/ES) <= REAL(EPS) .AND. REAL(EPS) <= REAL(FSY/ES))
     &    THEN
        SIGMA_S = ES*EPS
      ELSE IF (ABS(REAL(EPS))<= REAL(ESU)) THEN
        SIGMA_S = SIGN_RC(1D0,EPS)*(FSY+((FSU-FSY)/(ESU-FSY/ES))*
     &            (ABS_C(EPS)-FSY/ES))
      ELSE
        SIGMA_S = SIGN_RC(1D0,EPS)*(FSU+((ABS_C(EPS)-ESU))*
     &            CMPLX(50D0,0D0,KIND=8))
      END IF

      END SUBROUTINE SUB_S_E_STAHL_BL

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER STAHLSPANNUNGEN F�R KALTVERFORMTE
!     ST�HLE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_STAHL_KV(EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,
     &                            SIGMA_S)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)      :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
      DOUBLE COMPLEX, INTENT(OUT)     :: SIGMA_S

      DOUBLE COMPLEX      ::  ALPHA, KCC, DEPS_C, KAA, DEPS_C1
      DOUBLE PRECISION    ::  JAC, DF, F, TOL, STEP, D_I
      INTEGER             :: EXITFLAG, COUNTER, MAXCOUNTER

      INTERFACE
        FUNCTION ABS_C(VAL)
            DOUBLE COMPLEX             :: ABS_C
            DOUBLE COMPLEX, INTENT(IN) :: VAL
        END FUNCTION ABS_C

        FUNCTION SIGN_RC(VAL1,VAL2)
            DOUBLE COMPLEX               :: SIGN_RC
            DOUBLE PRECISION, INTENT(IN) :: VAL1
            DOUBLE COMPLEX  , INTENT(IN) :: VAL2
        END FUNCTION SIGN_RC

        FUNCTION F_S_E_KV(SIGMA,ES,KC,ALPHA)
            DOUBLE COMPLEX             :: F_S_E_KV
            DOUBLE COMPLEX, INTENT(IN) :: SIGMA,ES,KC,ALPHA
        END FUNCTION F_S_E_KV

        SUBROUTINE SUB_S_E_STAHL_BL(EPS,FSY,FSU,ESU,ES,SIGMA_S)
           DOUBLE COMPLEX, INTENT(IN) :: EPS,FSY,FSU,ESU,ES
           DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_S
        END SUBROUTINE SUB_S_E_STAHL_BL
      END INTERFACE

      ! BERECHNUNG DER STAHLSPANNUNG
      IF (REAL(KA) .LT. 0D0) THEN
        KAA=FSY/ES
      ELSE
        KAA=KA
      END IF

      ALPHA = LOG((ESU-FSU/ES)/KAA)/LOG(FSU/FSY)

      IF (REAL(KC) .LT. 0D0) THEN
        KCC = FSY/(KAA**(CMPLX(1D0,0D0,KIND=8)/ALPHA))
      ELSE
        KCC = KC
      END IF

      ! SETZEN DER STARTWERTE F�R DIE ITERATION
      STEP  = EPSILON(1D0)
      COUNTER = 0
      EXITFLAG = 1
      DF = 1.0D0
      F  = 1.0D0
      TOL = 1.0D-15
      MAXCOUNTER = 100

      ! STARTWERT F�R SPANNUNG
      CALL SUB_S_E_STAHL_BL(EPS,(FSY+FSU)*CMPLX(0.5D0,0D0,KIND=8),
     &                      FSU,ESU,ES,SIGMA_S)

      ! ITERATION REALTEIL DER SPANNUNG

10    IF ((ABS(F) .GT. TOL)) THEN

        COUNTER = COUNTER + 1

        IF (COUNTER .GT. 1) THEN
            SIGMA_S = CMPLX(REAL(SIGMA_S)-DF,STEP,KIND=8)
        ELSE
            SIGMA_S = CMPLX(REAL(SIGMA_S),STEP,KIND=8)
        END IF

        DEPS_C= F_S_E_KV(SIGMA_S,ES,KCC,ALPHA)-
     &          CMPLX(REAL(EPS),0D0,KIND=8)
        JAC = AIMAG(DEPS_C)/STEP
        F = REAL(DEPS_C)
        DF= F/JAC

        IF (COUNTER .GT. MAXCOUNTER) THEN
            F = 0D0
            DF= 0.0
            EXITFLAG = 2
        END IF

      GOTO 10

      END IF

      SIGMA_S = CMPLX(REAL(SIGMA_S),0D0,KIND=8)
      D_I=1D0
      TOL=1D-22
      COUNTER = 0

20    IF (ABS(D_I) .GT. TOL) THEN

        COUNTER = COUNTER + 1

        IF (COUNTER .GT. 1) THEN
            SIGMA_S = CMPLX(REAL(SIGMA_S),AIMAG(SIGMA_S)-D_I,KIND=8)
        ELSE
            SIGMA_S = CMPLX(REAL(SIGMA_S),0D0,KIND=8)
        END IF

        DEPS_C = F_S_E_KV(SIGMA_S,ES,KCC,ALPHA)-EPS
        DEPS_C1= F_S_E_KV(SIGMA_S+CMPLX(0D0,STEP,KIND=8),ES,KCC,ALPHA)
     &           -EPS
        JAC = (AIMAG(DEPS_C1)-AIMAG(DEPS_C))/STEP
        D_I = AIMAG(DEPS_C)/JAC

        IF (COUNTER .GT. MAXCOUNTER) THEN
            D_I = 0.0
            EXITFLAG = 2
        END IF

      GOTO 20

      END IF

      END SUBROUTINE SUB_S_E_STAHL_KV

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER STAHLSPANNUNGEN F�R WARMVERFORMTE
!     ST�HLE (NATURHART)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_STAHL_WV(EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC,
     &                            SIGMA_S)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)      :: EPS,FSY,FSU,ESU,ESV,ES,KA,KB,KC
      DOUBLE COMPLEX, INTENT(OUT)     :: SIGMA_S

      DOUBLE COMPLEX :: VORZEICHEN, ALPHA, KCC,EX

      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE

        FUNCTION SIGN_RC(VAL1,VAL2)
            DOUBLE COMPLEX               :: SIGN_RC
            DOUBLE PRECISION, INTENT(IN) :: VAL1
            DOUBLE COMPLEX  , INTENT(IN) :: VAL2
        END FUNCTION SIGN_RC

        FUNCTION ABS_C(VAL)
            DOUBLE COMPLEX             :: ABS_C
            DOUBLE COMPLEX, INTENT(IN) :: VAL
        END FUNCTION ABS_C

      FUNCTION EXP_C(Z_C)
            DOUBLE COMPLEX, INTENT(IN) :: Z_C
            DOUBLE COMPLEX             :: EXP_C, I
      END FUNCTION EXP_C

      END INTERFACE

      VORZEICHEN = SIGN_RC(1D0,EPS)
      EX = ABS_C(EPS)


      ! EINGABE VON KA UND KB OBLIGATORISCH -> KC WIRD BERECHNET FALLS KC<0
      IF (REAL(KC) .LT. 0D0) THEN
        KCC = CMPLX(1D0,0D0,KIND=8)/(CMPLX(1D0,0D0,KIND=8)-
     &        EXP_C((ESV-KB)/KA))
      ELSE
        KCC = KC
      END IF

      ALPHA = KA*(ESV-ESU)/(ESV-KB)

      ! BERECHNUNG DER STAHLSPANNUNG
      IF ((0D0 .LE. REAL(EX)) .AND. (REAL(EX) .LT. REAL(FSY/ES))) THEN
        SIGMA_S = ES*EX
      ELSEIF ((REAL(FSY/ES) .LE. REAL(EX)) .AND. (REAL(EX) .LE.
     & REAL(ESV))) THEN
        SIGMA_S = FSY
      ELSEIF (REAL(EX) .GT. REAL(ESV)) THEN
        SIGMA_S = FSY+(FSU-FSY)*KCC*(CMPLX(1D0,0D0,KIND=8)-
     &            EXP_C((ESV-EX)/ALPHA))
      END IF

      SIGMA_S = VORZEICHEN*SIGMA_S

      END SUBROUTINE SUB_S_E_STAHL_WV

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER MAXIMALEN STAHLSPANNUNG AM RISS IN
!     FUNKTION DER MITTLEREN DEHNUNG MITHILFE DES ZUGGURTMODELLS F�R
!     EIN BELIEBIGES WERKSTOFFGESETZ (BILINEAR, KALTVERFORMT,
!     WARMVERFORMT(NATURHART), TRILINEAR....)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_ZM(ZM,ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,
     &                      TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER, INTENT(IN) :: ZM
      DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,
     &                              TAU_B0,TAU_B1,EC,RHO,KA,KB,KC
      DOUBLE COMPLEX, INTENT(OUT):: SIGMA_SR

      ! INTERFACES ZU EXTERNEN SUBROUTINEN
      INTERFACE
      SUBROUTINE SUB_S_E_ZM_BL(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,TAU_B1,
     &                         EC,RHO,SIGMA_SR)
        DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                                TAU_B1,EC,RHO
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
      END SUBROUTINE SUB_S_E_ZM_BL

      SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,
     &                                   TAU_B0,TAU_B1,EC,RHO,SIGMA_SR)
        DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                                TAU_B1,EC,RHO
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
      END SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER

      SUBROUTINE SUB_S_E_ZM_KV(ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,
     &                         TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)
        DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,
     &                                TAU_B0,TAU_B1,EC,RHO,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
      END SUBROUTINE SUB_S_E_ZM_KV

      SUBROUTINE SUB_S_E_ZM_WV(ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,
     &                         TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)
        DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,
     &                                TAU_B0,TAU_B1,EC,RHO,KA,KB,KC
        DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
      END SUBROUTINE SUB_S_E_ZM_WV

      END INTERFACE

      ! UNTERSCHEIDUNG WERKSTOFFGESETZE

      IF (ABS(ZM-1.0D0) .LT. 0.1D0) THEN

        CALL SUB_S_E_ZM_BL(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,TAU_B1,EC,
     &                     RHO,SIGMA_SR)

      ELSEIF (ABS(ZM-1.0D0) .LT. 1.1D0) THEN

        CALL SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                               TAU_B1,EC,RHO,SIGMA_SR)

      ELSEIF (ABS(ZM-1.0D0) .LT. 2.1D0) THEN

        CALL SUB_S_E_ZM_KV(ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,TAU_B1,
     &                     EC,RHO,KA,KB,KC,SIGMA_SR)

      ELSEIF (ABS(ZM-1.0D0) .LT. 3.1D0) THEN

        CALL SUB_S_E_ZM_WV(ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,TAU_B1,
     &                     EC,RHO,KA,KB,KC,SIGMA_SR)

      END IF

      ! KANN BELIEBIG ERWEITERT WERDEN, Z.B.:

      ! ELSEIF (ABS(ZM-1.0D0) .LT. 4.1D0) THEN

      ! CALL SUB_S_E_ZM_TL(ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)

      ! END IF

      END SUBROUTINE SUB_S_E_ZM

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER MAXIMALEN STAHLSPANNUNG AM RISS IN
!     FUNKTION DER MITTLEREN DEHNUNG F�R EIN BILINEARES STAHLSTOFFGESETZ
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_ZM_BL(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,TAU_B1,
     &                         EC,RHO,SIGMA_SR)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)  :: ESM, SRM, DM, FSY, FSU, ESU, ES,
     &                               TAU_B0, TAU_B1, EC, RHO
      DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
      DOUBLE COMPLEX   :: X1, X2, N, ESH, ALPHA, ESU3, ESU2B
      DOUBLE COMPLEX   :: SIGMA_SR1, SIGMA_SR2, SIGMA_SR3, SIGMA_GRENZ,
     &                    SIGMA_GRENZ1

      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION SQRT_C(VAL)
        DOUBLE COMPLEX :: SQRT_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION SQRT_C
      END INTERFACE

      IF (REAL(DM) .GT. 0.1D0) THEN

      ! KONSTANTE MATERIALWERTE
      N = ES/EC
      ESH = (FSU-FSY)/(ESU-FSY/ES)

      ! BERECHNUNG DER STAHLSPANNUNG

      ! HILFSGR�SSEN
      ALPHA = CMPLX(1D0,0D0,KIND=8)+N*RHO

      X1 = SRM/CMPLX(2D0,0D0,KIND=8)*(SQRT_C(N*N*RHO*RHO+
     &     ((ES*ESM)/TAU_B0)*(DM/SRM))-N*RHO)

      X2 = ((DM*FSY*ESH)/(CMPLX(4D0,0D0,KIND=8)*TAU_B1*ALPHA*ES))*
     &     (SQRT_C(CMPLX(4D0,0D0,KIND=8)*((ALPHA*ES)/ESH)*((((SRM)*
     &     TAU_B1)/(DM*FSY))*((ALPHA*ES*ESM)/FSY-N*RHO)-TAU_B1/
     &     (CMPLX(4D0,0D0,KIND=8)*ALPHA*TAU_B0))+
     &     CMPLX(1D0,0D0,KIND=8))-CMPLX(1D0,0D0,KIND=8))


      ! MAXIMALE STAHLSPANNUNG AM RISS (REGIME 1,2,3)
      SIGMA_SR1 = ESM*ES+(TAU_B0*SRM)/DM
      SIGMA_SR2 = FSY+2D0*(((TAU_B0*SRM)/DM-SQRT_C((FSY-ES*ESM)*
     &            ((TAU_B1*SRM)/DM)*(TAU_B0/TAU_B1-ES/ESH)+(ES/ESH)*
     &            TAU_B0*TAU_B1*((SRM*SRM)/(DM*DM))))/
     &            (TAU_B0/TAU_B1-ES/ESH))
      SIGMA_SR3  = FSY+ESH*(ESM-FSY/ES)+(TAU_B1*SRM)/DM

      ! FALLUNTERSCHEIDUNG
      IF (REAL(SIGMA_SR1) > REAL(((2D0*TAU_B0*REAL(SRM))/DM)*ALPHA)
     &   .AND. REAL(SIGMA_SR1) <= REAL(FSY)) THEN

        SIGMA_SR = SIGMA_SR1

      ELSE IF (REAL(SIGMA_SR2) > REAL(((2D0*TAU_B0*REAL(SRM))/DM)*ALPHA)
     &        .AND. REAL(FSY) < REAL(SIGMA_SR2)
     &        .AND. REAL(SIGMA_SR2) <= REAL(FSY+
     &              (2D0*TAU_B1*REAL(SRM))/DM)
     &        .AND. REAL(SIGMA_SR2) <= REAL(FSU)) THEN

        SIGMA_SR = SIGMA_SR2

      ELSE IF (REAL((FSY+(2*TAU_B1*REAL(SRM))/DM)) < REAL(SIGMA_SR3)
     &        .AND. REAL(SIGMA_SR3) <= REAL(FSU)) THEN

        SIGMA_SR = SIGMA_SR3

      ELSE

        ESU2B = (ES*DM*DM*FSY*FSY*TAU_B1-ESH*TAU_B0*DM*DM*FSY*FSY-
     &          CMPLX(2D0,0D0,KIND=8)*ES*DM*DM*FSY*FSU*TAU_B1+
     &          CMPLX(2D0,0D0,KIND=8)*ESH*TAU_B0*DM*DM*FSY*FSU+ES*DM*DM*
     &          FSU*FSU*TAU_B1-ESH*TAU_B0*DM*DM*FSU*FSU+
     &          CMPLX(4D0,0D0,KIND=8)*ESH*DM*FSY*SRM*TAU_B1*TAU_B1-
     &          CMPLX(4D0,0D0,KIND=8)*ESH*TAU_B0*DM*FSY*SRM*TAU_B1+
     &          CMPLX(4D0,0D0,KIND=8)*ESH*TAU_B0*DM*SRM*FSU*TAU_B1-
     &          CMPLX(4D0,0D0,KIND=8)*ESH*TAU_B0*SRM*SRM*TAU_B1*TAU_B1)/
     &          (CMPLX(4D0,0D0,KIND=8)*ES*ESH*DM*SRM*TAU_B1*TAU_B1)

        ESU3 = ((FSU-(TAU_B1*SRM/DM)-FSY)/ESH)+(FSY/ES)

        SIGMA_GRENZ1 = FSY + (CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM/DM)

        SIGMA_GRENZ = (CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM)*
     &              (CMPLX(1D0,0D0,KIND=8)+N*RHO)

        IF  (REAL(SIGMA_GRENZ1) <= REAL(FSU)) THEN

          SIGMA_SR = FSU+(ESM-ESU3)*CMPLX(50D0,0D0,KIND=8)

        ELSE

          SIGMA_SR = FSU+(ESM-ESU2B)*CMPLX(50D0,0D0,KIND=8)

        END IF

      END IF

      ELSE

        SIGMA_SR = CMPLX(0D0,0D0,KIND=8)

      END IF

      END SUBROUTINE SUB_S_E_ZM_BL

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER MAXIMALEN STAHLSPANNUNG AM RISS IN
!     FUNKTION DER MITTLEREN DEHNUNG F�R EIN BILINEARES STAHLSTOFFGESETZ
!     (ERWEITERTES ZUGGURTMODELL NACH SEELHOFER)
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,
     &                                   TAU_B0,TAU_B1,EC,RHO,SIGMA_SR)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)  :: ESM, SRM, DM, FSY, FSU, ESU, ES,
     &                               TAU_B0, TAU_B1, EC, RHO
      DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
      DOUBLE COMPLEX   :: X1, X2, N, ESH, ALPHA, ESU3, ESU2B
      DOUBLE COMPLEX   :: SIGMA_SR1A, SIGMA_SR1B, SIGMA_SR2A,
     &                    SIGMA_SR2B, SIGMA_SR3, SIGMA_GRENZ,
     &                    SIGMA_GRENZ1

      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION ABS_C(VAL)
        DOUBLE COMPLEX :: ABS_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION ABS_C

      FUNCTION SQRT_C(VAL)
        DOUBLE COMPLEX :: SQRT_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION SQRT_C
      END INTERFACE

      IF (REAL(DM) .GT. 0.1D0) THEN

      ! KONSTANTE MATERIALWERTE
      N = ES/EC
      ESH = (FSU-FSY)/(ESU-FSY/ES)

      ! BERECHNUNG DER STAHLSPANNUNG

      ! HILFSGR�SSEN
      ALPHA = CMPLX(1D0,0D0,KIND=8)+N*RHO

      X1 = SRM/CMPLX(2D0,0D0,KIND=8)*(SQRT_C(N*N*RHO*RHO+((ES*ESM)/
     &     TAU_B0)*(DM/SRM))-N*RHO)

      X2 = ((DM*FSY*ESH)/(CMPLX(4D0,0D0,KIND=8)*TAU_B1*ALPHA*ES))*
     &     (SQRT_C(CMPLX(4D0,0D0,KIND=8)*((ALPHA*ES)/ESH)*
     &     ((((SRM)*TAU_B1)/(DM*FSY))*((ALPHA*ES*ESM)/FSY-N*RHO)-TAU_B1/
     &     (CMPLX(4D0,0D0,KIND=8)*ALPHA*TAU_B0))+CMPLX(1D0,0D0,KIND=8))-
     &     CMPLX(1D0,0D0,KIND=8))


      ! MAXIMALE STAHLSPANNUNG AM RISS (REGIME 1A,1B,2A,2B,3)
      SIGMA_SR1A = X1*((CMPLX(4D0,0D0,KIND=8)*TAU_B0)/DM)*ALPHA
      SIGMA_SR1B = ESM*ES+(TAU_B0*SRM)/DM
      SIGMA_SR2A = FSY+X2*((CMPLX(4D0,0D0,KIND=8)*TAU_B1)/DM)
      SIGMA_SR2B = FSY+CMPLX(2D0,0D0,KIND=8)*(((TAU_B0*SRM)/DM-
     &             SQRT_C((FSY-ES*ESM)*((TAU_B1*SRM)/DM)*
     &             (TAU_B0/TAU_B1-ES/ESH)+(ES/ESH)*TAU_B0*TAU_B1*
     &             ((SRM*SRM)/(DM*DM))))/(TAU_B0/TAU_B1-ES/ESH))
      SIGMA_SR3  = FSY+ESH*(ESM-FSY/ES)+(TAU_B1*SRM)/DM

      ! FALLUNTERSCHEIDUNG
      IF (REAL(SIGMA_SR1A) <= REAL(((CMPLX(2D0,0D0,KIND=8)*TAU_B0*
     &   REAL(SRM))/DM)*ALPHA) .AND. REAL(SIGMA_SR1A) <= REAL(FSY))THEN

        SIGMA_SR = SIGMA_SR1A

      ELSE IF (REAL(SIGMA_SR1B) > REAL(((CMPLX(2D0,0D0,KIND=8)*TAU_B0*
     &        REAL(SRM))/DM)*ALPHA) .AND. REAL(SIGMA_SR1B)
     &        <= REAL(FSY)) THEN

        SIGMA_SR = SIGMA_SR1B

      ELSE IF (REAL(SIGMA_SR2A) <= REAL(((CMPLX(2D0,0D0,KIND=8)*TAU_B0*
     &        REAL(SRM))/DM)*ALPHA) .AND. REAL(FSY) < REAL(SIGMA_SR2A)
     &        .AND. REAL(SIGMA_SR2A) <= REAL(FSY+(CMPLX(2D0,0D0,KIND=8)
     &       *TAU_B1*REAL(SRM))/DM) .AND. REAL(SIGMA_SR2A) <=
     &       REAL(FSU)) THEN

        SIGMA_SR = SIGMA_SR2A

      ELSE IF (REAL(SIGMA_SR2B) > REAL(((CMPLX(2D0,0D0,KIND=8)*TAU_B0*
     &         REAL(SRM))/DM)*ALPHA) .AND. REAL(FSY) < REAL(SIGMA_SR2B)
     &        .AND. REAL(SIGMA_SR2B) <= REAL(FSY+(CMPLX(2D0,0D0,KIND=8)*
     &        TAU_B1*REAL(SRM))/DM) .AND. REAL(SIGMA_SR2B) <=
     &        REAL(FSU)) THEN

        SIGMA_SR = SIGMA_SR2B

      ELSE IF (REAL((FSY+(CMPLX(2D0,0D0,KIND=8)*TAU_B1*REAL(SRM))/DM))
     &        < REAL(SIGMA_SR3) .AND. REAL(SIGMA_SR3) <= REAL(FSU))THEN

        SIGMA_SR = SIGMA_SR3

      ELSE

        ESU2B = (ES*DM*DM*FSY*FSY*TAU_B1-ESH*TAU_B0*DM*DM*FSY*FSY-
     &          CMPLX(2D0,0D0,KIND=8)*ES*DM*DM*FSY*FSU*TAU_B1+
     &          CMPLX(2D0,0D0,KIND=8)*ESH*TAU_B0*DM*DM*FSY*FSU+ES*DM*DM*
     &          FSU*FSU*TAU_B1-ESH*TAU_B0*DM*DM*FSU*FSU+
     &          CMPLX(4D0,0D0,KIND=8)*ESH*DM*FSY*SRM*TAU_B1*TAU_B1-
     &          CMPLX(4D0,0D0,KIND=8)*ESH*TAU_B0*DM*FSY*SRM*TAU_B1+
     &          CMPLX(4D0,0D0,KIND=8)*ESH*TAU_B0*DM*SRM*FSU*TAU_B1-
     &          CMPLX(4D0,0D0,KIND=8)*ESH*TAU_B0*SRM*SRM*TAU_B1*TAU_B1)/
     &          (CMPLX(4D0,0D0,KIND=8)*ES*ESH*DM*SRM*TAU_B1*TAU_B1)

        ESU3 = ((FSU-(TAU_B1*SRM/DM)-FSY)/ESH)+(FSY/ES)

        SIGMA_GRENZ1 = FSY + (CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM/DM)

        SIGMA_GRENZ = (CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM)*
     &                (CMPLX(1D0,0D0,KIND=8)+N*RHO)

        IF  (REAL(SIGMA_GRENZ1) <= REAL(FSU)) THEN

          SIGMA_SR = FSU+(ESM-ESU3)*CMPLX(50D0,0D0,KIND=8)

        ELSE

          SIGMA_SR = FSU+(ESM-ESU2B)*CMPLX(50D0,0D0,KIND=8)

        END IF

      END IF

      ELSE
        SIGMA_SR = CMPLX(0D0,0D0,KIND=8)
      END IF

      END SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER MAXIMALEN STAHLSPANNUNG AM RISS IN
!     FUNKTION DER MITTLEREN DEHNUNG F�R KALTVERFORMTEN STAHL
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              17.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_ZM_KV(ESM,SRM,DM,FSY,FSU,ESU,ESV,ES,TAU_B0,
     &                         TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)  :: ESM, SRM, DM, FSY, FSU, ESU, ESV,
     &                               ES, TAU_B0, TAU_B1, EC, RHO,
     &                               KA, KB, KC
      DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR


      DOUBLE COMPLEX      ::  ALPHA, KCC, KAA, DEPS_C1,STEP1,STEP2,
     &                        STEP3,STEP4,K
      DOUBLE COMPLEX, DIMENSION(4,1) :: DEPS_C
      DOUBLE PRECISION    ::  JAC, DF, F, TOL, STEP, D_I
      INTEGER             ::  EXITFLAG, COUNTER, MAXCOUNTER

      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE

        FUNCTION F_S_E_KV_ZM(SIGMA_SR,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                       TAU_B1,EC,RHO,KC,ALPHA)
            DOUBLE COMPLEX             :: F_S_E_KV_ZM
            DOUBLE COMPLEX, INTENT(IN) :: SIGMA_SR,SRM,DM,FSY,FSU,ESU,
     &                                    ES,TAU_B0,TAU_B1,EC,RHO,
     &                                    KC,ALPHA
        END FUNCTION F_S_E_KV_ZM

        SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,
     &                                     TAU_B0,TAU_B1,EC,RHO,
     &                                     SIGMA_SR)
            DOUBLE COMPLEX, INTENT(IN) :: ESM,SRM,DM,FSY,FSU,ESU,ES,
     &                                    TAU_B0,TAU_B1,EC,RHO
            DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR
        END SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER

      END INTERFACE

      ! BERECHNUNG DER STAHLSPANNUNG
      IF (REAL(DM) .GT. 0.1D0) THEN

      IF (REAL(KA) .LT. 0D0) THEN
        KAA=FSY/ES
      ELSE
        KAA=KA
      END IF

      ALPHA = LOG((ESU-FSU/ES)/KAA)/LOG(FSU/FSY)

      IF (REAL(KC) .LT. 0D0) THEN
        KCC = FSY/(KAA**(1.0D0/ALPHA))
      ELSE
        KCC = KC
      END IF

      ! SETZEN DER STARTWERTE F�R DIE ITERATION
      STEP  = EPSILON(1D0)
      COUNTER = 0
      EXITFLAG = 1
      DF = 1.0D0
      F  = 1.0D0
      TOL = 1.0D-14
      MAXCOUNTER = 100

      K = CMPLX(-0.5D0,0.5D0*(SQRT(3D0)),KIND=8)

      STEP1 = K*CMPLX(STEP,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8)
      STEP2 = -K*CMPLX(STEP,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8)
      STEP3 = K*CMPLX(STEP,0D0,KIND=8)
      STEP4 = -K*CMPLX(STEP,0D0,KIND=8)

      ! STARTWERT F�R SPANNUNG

      CALL SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                             TAU_B1,EC,RHO,SIGMA_SR)

      ! ITERATION REALTEIL DER SPANNUNG

10    IF ((ABS(F) .GT. TOL)) THEN

        COUNTER = COUNTER + 1

        IF (COUNTER .GT. 1) THEN
            SIGMA_SR = CMPLX(REAL(SIGMA_SR)-DF,0D0,KIND=8)
        ELSE
            SIGMA_SR = CMPLX(REAL(SIGMA_SR),0D0,KIND=8)
        END IF

        DEPS_C(1,1)= F_S_E_KV_ZM(SIGMA_SR+STEP1,SRM,DM,FSY,FSU,ESU,
     &  ES,TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-CMPLX(REAL(ESM),0D0,KIND=8)
        DEPS_C(2,1)= F_S_E_KV_ZM(SIGMA_SR+STEP2,SRM,DM,FSY,FSU,ESU,
     &  ES,TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-CMPLX(REAL(ESM),0D0,KIND=8)
        DEPS_C(3,1)= F_S_E_KV_ZM(SIGMA_SR+STEP3,SRM,DM,FSY,FSU,ESU,
     &  ES,TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-CMPLX(REAL(ESM),0D0,KIND=8)
        DEPS_C(4,1)= F_S_E_KV_ZM(SIGMA_SR+STEP4,SRM,DM,FSY,FSU,ESU,
     &  ES,TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-CMPLX(REAL(ESM),0D0,KIND=8)

        JAC  = AIMAG(32D0*(DEPS_C(1,1)-DEPS_C(2,1))-(DEPS_C(3,1)-
     &         DEPS_C(4,1)))/(15D0*SQRT(3D0)*STEP)

        F = REAL(DEPS_C(1,1))
        DF= F/JAC

        IF (COUNTER .GT. MAXCOUNTER) THEN
            F = 0D0
            DF= 0.0D0
            EXITFLAG = 2
        END IF

        GOTO 10
      END IF

      SIGMA_SR = CMPLX(REAL(SIGMA_SR),0D0,KIND=8)
      D_I=1D0
      TOL=1D-20
      COUNTER = 0

20    IF (ABS(D_I) .GT. TOL) THEN

        COUNTER = COUNTER + 1

        IF (COUNTER .GT. 1) THEN
            SIGMA_SR = CMPLX(REAL(SIGMA_SR),AIMAG(SIGMA_SR)-D_I,KIND=8)
        ELSE
            SIGMA_SR = CMPLX(REAL(SIGMA_SR),0D0,KIND=8)
        END IF

        DEPS_C(1,1) = F_S_E_KV_ZM(SIGMA_SR,SRM,DM,FSY,FSU,ESU,ES,
     &                TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-ESM
        DEPS_C1= F_S_E_KV_ZM(SIGMA_SR+CMPLX(0D0,STEP,KIND=8),SRM,DM,
     &           FSY,FSU,ESU,ES,TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-ESM
        JAC = (AIMAG(DEPS_C1)-AIMAG(DEPS_C(1,1)))/STEP
        D_I = AIMAG(DEPS_C(1,1))/JAC

       IF (COUNTER .GT. MAXCOUNTER) THEN
            D_I= 0.0
            EXITFLAG = 2
        END IF

        GOTO 20
      END IF

      ELSE
        SIGMA_SR = CMPLX(0D0,0D0,KIND=8)
      END IF

      END SUBROUTINE SUB_S_E_ZM_KV

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER MAXIMALEN STAHLSPANNUNG AM RISS IN
!     FUNKTION DER MITTLEREN DEHNUNG F�R WARMVERFORMTE ST�HLE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              05.05.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_S_E_ZM_WV(ESM,SRM,DM,FSY,FSU,ESV,ESU,ES,TAU_B0,
     &                         TAU_B1,EC,RHO,KA,KB,KC,SIGMA_SR)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN)  :: ESM, SRM, DM, FSY, FSU, ESV, ESU,
     &                               ES, TAU_B0, TAU_B1, EC, RHO,
     &                               KA, KB, KC
      DOUBLE COMPLEX, INTENT(OUT) :: SIGMA_SR

      DOUBLE COMPLEX      ::  ALPHA, KCC, DEPS_C1,STEP1,STEP2,STEP3,
     &                        STEP4,K,EPS_Y,EPS_V,SIG_V
      DOUBLE COMPLEX, DIMENSION(4,1) :: DEPS_C
      DOUBLE PRECISION    ::  JAC, DF, F, TOL, STEP, D_I
      INTEGER             ::  EXITFLAG, COUNTER, MAXCOUNTER

      ! INTERFACE ZU EXTERNEN FUNKTIONEN
      INTERFACE

        FUNCTION F_S_E_WV_ZM(SIGMA_SR,SRM,DM,FSY,FSU,ESV,ES,TAU_B0,
     &                       TAU_B1,EC,RHO,KC,ALPHA)
            DOUBLE COMPLEX             :: F_S_E_WV_ZM
            DOUBLE COMPLEX, INTENT(IN) :: SIGMA_SR,SRM,DM,FSY,FSU,ESV,
     &                                    ES,TAU_B0,TAU_B1,
     &                                    EC,RHO,KC,ALPHA
        END FUNCTION F_S_E_WV_ZM

        FUNCTION EXP_C(Z_C)
            DOUBLE COMPLEX, INTENT(IN) :: Z_C
            DOUBLE COMPLEX             :: EXP_C, I
        END FUNCTION EXP_C

        SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER(EM,SRM,DM,FY,FU,EU,ES,
     &                                    TAU_B0,TAU_B1,EC,RHO,SIGMA_SR)
            DOUBLE COMPLEX  , INTENT(IN)  :: DM, FY, FU, EU, ES,
     &                                       TAU_B0, TAU_B1, EC, RHO
            DOUBLE COMPLEX  , INTENT(IN)  :: EM, SRM
            DOUBLE COMPLEX  , INTENT(OUT) :: SIGMA_SR
        END SUBROUTINE SUB_S_E_ZM_BL_SEELHOFER

      END INTERFACE


      ! BERECHNUNG DER STAHLSPANNUNG

      IF (REAL(DM) .GT. 0.1D0) THEN

      IF (REAL(KC) .LT. 0D0) THEN
        KCC = CMPLX(1D0,0D0,KIND=8)/(CMPLX(1D0,0D0,KIND=8)-
     &        EXP_C((ESV-KB)/KA))
      ELSE
        KCC = KC
      END IF

      ALPHA = KA*(ESV-ESU)/(ESV-KB)

      ! SETZEN DER STARTWERTE F�R DIE ITERATION
      STEP  = EPSILON(1D0)
      COUNTER = 0
      EXITFLAG = 1
      DF = 1.0D0
      F  = 1.0D0
      TOL = 1.0D-14
      MAXCOUNTER = 100

      K = CMPLX(-0.5D0,0.5D0*(SQRT(3D0)),KIND=8)

      STEP1 = K*CMPLX(STEP,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8)
      STEP2 = -K*CMPLX(STEP,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8)
      STEP3 = K*CMPLX(STEP,0D0,KIND=8)
      STEP4 = -K*CMPLX(STEP,0D0,KIND=8)

      ! STARTWERT F�R SPANNUNG !

      SIG_V=FSY+CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM/DM
      EPS_V= F_S_E_WV_ZM(SIG_V,SRM,DM,FSY,FSU,ESV,ES,TAU_B0,TAU_B1,
     &                   EC,RHO,KCC,ALPHA)
      EPS_Y= F_S_E_WV_ZM(FSY,SRM,DM,FSY,FSU,ESV,ES,TAU_B0,TAU_B1,
     &                   EC,RHO,KCC,ALPHA)

      IF (REAL(ESM).LE.REAL(EPS_Y)) THEN
        CALL SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                               TAU_B1,EC,RHO,SIGMA_SR)
      ELSEIF ((REAL(ESM).GT.REAL(EPS_Y)) .AND. (REAL(ESM).LT.
     &         REAL(EPS_V))) THEN
        SIGMA_SR=FSY+(SIG_V-FSY)/(EPS_V-EPS_Y)*(ESM-EPS_Y)
      ELSE
        CALL SUB_S_E_ZM_BL_SEELHOFER(ESM,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                               TAU_B1,EC,RHO,SIGMA_SR)
      END IF

      !ITERATION REALTEIL DER SPANNUNG!

10    IF ((ABS(F) .GT. TOL)) THEN

        COUNTER = COUNTER + 1

        IF (COUNTER .GT. 1) THEN
            SIGMA_SR = CMPLX(REAL(SIGMA_SR)-DF,0D0,KIND=8)
        ELSE
            SIGMA_SR = CMPLX(REAL(SIGMA_SR),0D0,KIND=8)
        END IF

        DEPS_C(1,1)= F_S_E_WV_ZM(SIGMA_SR+STEP1,SRM,DM,FSY,FSU,ESV,ES,
     &                           TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-
     &                           CMPLX(REAL(ESM),0D0,KIND=8)
        DEPS_C(2,1)= F_S_E_WV_ZM(SIGMA_SR+STEP2,SRM,DM,FSY,FSU,ESV,ES,
     &                           TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-
     &                           CMPLX(REAL(ESM),0D0,KIND=8)
        DEPS_C(3,1)= F_S_E_WV_ZM(SIGMA_SR+STEP3,SRM,DM,FSY,FSU,ESV,ES,
     &                           TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-
     &                           CMPLX(REAL(ESM),0D0,KIND=8)
        DEPS_C(4,1)= F_S_E_WV_ZM(SIGMA_SR+STEP4,SRM,DM,FSY,FSU,ESV,ES,
     &                           TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-
     &                           CMPLX(REAL(ESM),0D0,KIND=8)

        JAC  = AIMAG(32D0*(DEPS_C(1,1)-DEPS_C(2,1))-(DEPS_C(3,1)-
     &         DEPS_C(4,1)))/(15D0*SQRT(3D0)*STEP)

        F = REAL(DEPS_C(1,1))
        DF= F/JAC

        IF (COUNTER .GT. MAXCOUNTER) THEN
            F = 0D0
            DF= 0.0D0
            EXITFLAG = 2
        END IF

        GOTO 10
      END IF

      SIGMA_SR = CMPLX(REAL(SIGMA_SR),0D0,KIND=8)
      D_I=1D0
      TOL=1D-20
      COUNTER = 0

20    IF (ABS(D_I) .GT. TOL) THEN

        COUNTER = COUNTER + 1

        IF (COUNTER .GT. 1) THEN
            SIGMA_SR = CMPLX(REAL(SIGMA_SR),AIMAG(SIGMA_SR)-D_I,KIND=8)
        ELSE
            SIGMA_SR = CMPLX(REAL(SIGMA_SR),0D0,KIND=8)
        END IF

        DEPS_C(1,1) = F_S_E_WV_ZM(SIGMA_SR,SRM,DM,FSY,FSU,ESV,ES,
     &                           TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-ESM
        DEPS_C1= F_S_E_WV_ZM(SIGMA_SR+CMPLX(0D0,STEP,KIND=8),SRM,DM,
     &           FSY,FSU,ESV,ES,TAU_B0,TAU_B1,EC,RHO,KCC,ALPHA)-ESM
        JAC = (AIMAG(DEPS_C1)-AIMAG(DEPS_C(1,1)))/STEP
        D_I = AIMAG(DEPS_C(1,1))/JAC

       IF (COUNTER .GT. MAXCOUNTER) THEN
            D_I= 0.0
            EXITFLAG = 2
        END IF

        GOTO 20
      END IF

      ELSE
        SIGMA_SR = CMPLX(0D0,0D0,KIND=8)
      END IF

      END SUBROUTINE SUB_S_E_ZM_WV


!-----------------------------------------------------------------------
!
!     SUBROUTINEN F�R HILFSFUNKTIONEN
!
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER HAUPTVERZERRUNGEN E1 UND E3
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_E1_E3(EX,EY,GAMMA_XY,E1,E3)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX,  INTENT(IN)  :: EX, EY, GAMMA_XY
      DOUBLE COMPLEX,  INTENT(OUT) :: E1, E3

      INTERFACE
        FUNCTION SQRT_C(VAL)
            DOUBLE COMPLEX :: SQRT_C
            DOUBLE COMPLEX, INTENT(IN) :: VAL
        END FUNCTION SQRT_C
      END INTERFACE

      ! BERECHNUNG DER HAUPTVERZERRUNGEN
      E1 = (CMPLX(1D0,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8))*(EX+EY) +
     &     (CMPLX(1D0,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8))*(SQRT_C((EX-EY)
     &     *(EX-EY)+GAMMA_XY*GAMMA_XY))

      E3 = (CMPLX(1D0,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8))*(EX+EY) -
     &     (CMPLX(1D0,0D0,KIND=8)/CMPLX(2D0,0D0,KIND=8))*(SQRT_C((EX-EY)
     &     *(EX-EY)+GAMMA_XY*GAMMA_XY))

      END SUBROUTINE SUB_E1_E3

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BERECHNUNG DER BERECHNUNG DER HAUPTVERZERRUNGS-
!     RICHTUNG NACH DER ALLGEMEINEN G�LTIGEN KINEMATISCHEN
!     VERTR�GLICHKEITSBEZIEHUNG
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.03.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_THETA_ALLGEMEIN(EX,EY,GAMMA_XY,THETA)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: EX, EY, GAMMA_XY
      DOUBLE COMPLEX, INTENT(OUT) :: THETA
      DOUBLE COMPLEX :: PI
      LOGICAL :: LR, LC

      ! INTERFACES ZU EXTERNEN FUNKTIONEN
      INTERFACE
      FUNCTION ATAN2_C(Y,X)
        DOUBLE COMPLEX             :: ATAN2_C
        DOUBLE COMPLEX, INTENT(IN) :: X,Y
      END FUNCTION ATAN2_C
      END INTERFACE

      ! BERECHNUNG THETA
      PI = CMPLX(4.D0*ATAN(1.0D0),0D0,KIND=8)

      IF (REAL(GAMMA_XY) .EQ. 0D0 .AND. REAL(EY) .EQ. REAL(EX)) THEN

        THETA = PI/CMPLX(4.D0,0D0,KIND=8)

      ELSE IF (REAL(GAMMA_XY) >= 0D0 .AND. REAL(EY) >= REAL(EX)) THEN

        THETA = CMPLX(0.5D0,0D0,KIND=8)*ATAN2_C(GAMMA_XY,(EY-EX))

      ELSE IF (REAL(GAMMA_XY) >= 0D0 .AND. REAL(EY) < REAL(EX)) THEN

        THETA = CMPLX(0.5D0,0D0,KIND=8)*ATAN2_C(GAMMA_XY,(EY-EX))

      ELSE IF (REAL(GAMMA_XY) < 0D0 .AND. REAL(EY) < REAL(EX)) THEN

        THETA = CMPLX(0.5D0,0D0,KIND=8)*ATAN2_C(GAMMA_XY,(EY-EX))

      ELSE IF (REAL(GAMMA_XY) < 0D0 .AND. REAL(EY) >= REAL(EX)) THEN

        THETA = CMPLX(0.5D0,0D0,KIND=8)*ATAN2_C(GAMMA_XY,(EY-EX))+PI

      END IF

      LR = ISNAN(REAL(THETA))
      LC = ISNAN(AIMAG(THETA))

      IF (LR) THEN
        THETA = CMPLX(0D0,AIMAG(THETA),KIND=8)
      END IF

      IF (LC) THEN
        THETA = CMPLX(REAL(THETA),0D0,KIND=8)
      END IF

      END SUBROUTINE SUB_THETA_ALLGEMEIN

!-----------------------------------------------------------------------
!     SUBROUTINE ZUR BESTIMMUNG IN WELCHER SCHICHT SICH DIE BERECHNUNG
!     BEFINDENT.
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              03.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_SCHICHTINFO(MATERIAL_ORG,KLAYER
     &                              ,SCHICHTINFO,IREF,ZSI)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE PRECISION, DIMENSION(76), INTENT(IN) :: MATERIAL_ORG
      INTEGER, INTENT(IN) :: KLAYER
      INTEGER, INTENT(OUT) :: SCHICHTINFO
      INTEGER, DIMENSION(4), INTENT(OUT) :: IREF
      DOUBLE PRECISION, DIMENSION(4),INTENT(OUT) :: ZSI
      INTEGER :: IREF_1, IREF_2, IREF_3, IREF_4, DIMENS


      DOUBLE COMPLEX ::   DELTA_H, ZS1, ZS2, ZS3, ZS4, CU, CO,
     &                    DM1, DM2, DM3, DM4, H, N, AS1, AS2, AS3, AS4


      ! EINLESEN DER BEN�TIGTEN VARIABELN
      DIMENS = INT(MATERIAL_ORG(1))

      N = CMPLX(MATERIAL_ORG(3),0D0,KIND=8)
      H = CMPLX(MATERIAL_ORG(4),0D0,KIND=8)
      CO = CMPLX(MATERIAL_ORG(5),0D0,KIND=8)
      CU = CMPLX(MATERIAL_ORG(6),0D0,KIND=8)

      DM1 = CMPLX(MATERIAL_ORG(49),0D0,KIND=8)
      DM2 = CMPLX(MATERIAL_ORG(36),0D0,KIND=8)
      DM3 = CMPLX(MATERIAL_ORG(23),0D0,KIND=8)
      DM4 = CMPLX(MATERIAL_ORG(10),0D0,KIND=8)

      AS1 = CMPLX(MATERIAL_ORG(48),0D0,KIND=8)
      AS2 = CMPLX(MATERIAL_ORG(35),0D0,KIND=8)
      AS3 = CMPLX(MATERIAL_ORG(22),0D0,KIND=8)
      AS4 = CMPLX(MATERIAL_ORG(9),0D0,KIND=8)

      DELTA_H = H/N

      ! SCHWERPUNKTE DER BEWERHUNGSLAGEN

      ZS1 = -(H/CMPLX(2D0,0D0,KIND=8))+CU+(DM1/CMPLX(2D0,0D0,KIND=8))     !ABSTAND VON MITTELEBENE DER PLATTE BIS ZUM S-PUNKT DER 1.LAGE [MM]
      ZS2 = -(H/CMPLX(2D0,0D0,KIND=8))+CU+DM1+
     &       (DM2/CMPLX(2D0,0D0,KIND=8)) !ABSTAND VON MITTELEBENE DER PLATTE BIS ZUM S-PUNKT DER 2.LAGE [MM]
      ZS3 = (H/CMPLX(2D0,0D0,KIND=8))-
     &       (CO+DM4+(DM3/CMPLX(2D0,0D0,KIND=8)))!ABSTAND VON MITTELEBENE DER PLATTE BIS ZUM S-PUNKT DER 3.LAGE [MM]
      ZS4 = (H/CMPLX(2D0,0D0,KIND=8))-(CO+(DM4/CMPLX(2D0,0D0,KIND=8)))    !ABSTAND VON MITTELEBENE DER PLATTE BIS ZUM S-PUNKT DER 4.LAGE [MM]

      ZSI(1) = REAL(ZS1)
      ZSI(2) = REAL(ZS2)
      ZSI(3) = REAL(ZS3)
      ZSI(4) = REAL(ZS4)

      ! BESTIMMUNG DER BEWEHRTEN SCHICHT

      IREF_1 = INT(FLOOR(REAL(((H/CMPLX(2D0,0D0,KIND=8))+ZS1)/DELTA_H))+
     &         REAL(CMPLX(1D0,0D0,KIND=8)))
      IREF_2 = INT(FLOOR(REAL(((H/CMPLX(2D0,0D0,KIND=8))+ZS2)/DELTA_H))+
     &         REAL(CMPLX(1D0,0D0,KIND=8)))
      IREF_3 = INT(CEILING(REAL(((H/CMPLX(2D0,0D0,KIND=8))+ZS3)
     &          /DELTA_H)))
      IREF_4 = INT(CEILING(REAL(((H/CMPLX(2D0,0D0,KIND=8))+ZS4)
     &          /DELTA_H)))

      IREF(1) = IREF_1
      IREF(2) = IREF_2
      IREF(3) = IREF_3
      IREF(4) = IREF_4

      IF (DIMENS .EQ. 2) THEN ! 3D-BERECHNUNG:

        IF (REAL(N) .GT. 1D0) THEN

            IF (KLAYER .EQ. IREF_1) THEN

                SCHICHTINFO = 1

            ELSE IF (KLAYER .EQ. IREF_2) THEN

                SCHICHTINFO = 2

            ELSE IF (KLAYER .EQ. IREF_3) THEN

                SCHICHTINFO = 3

            ELSE IF (KLAYER .EQ. IREF_4) THEN

                SCHICHTINFO = 4

            ELSE

            SCHICHTINFO = 0

            END IF
        ELSE

            SCHICHTINFO = 5
        END IF

      ELSE ! 2D-BERECHNUNG:

      SCHICHTINFO = 6

      END IF

      END SUBROUTINE SUB_SCHICHTINFO


!-----------------------------------------------------------------------
!     SUBROUTINE ZUM NEUAUFBAU DER MATERIALMATRIX.
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              02.06.2014
!-----------------------------------------------------------------------
      SUBROUTINE SUB_MATERIAL(MATERIAL_ORG,SCHICHTINFO,IREF,ZSI,
     &                        KLAYER,IELEMENT,MATERIAL)


      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE PRECISION, DIMENSION(76), INTENT(IN) :: MATERIAL_ORG
      INTEGER, INTENT(IN) :: SCHICHTINFO, IELEMENT, KLAYER
      DOUBLE PRECISION,DIMENSION(4),INTENT(IN)    :: ZSI
      INTEGER, DIMENSION(4),INTENT(IN)            :: IREF
      DOUBLE PRECISION, DIMENSION(60), INTENT(OUT) :: MATERIAL

      ! �BERGABE DER MATERIALKENNWERTE

      ! ALLGEMEIN:
      MATERIAL(1) = MATERIAL_ORG(1)
      MATERIAL(2) = MATERIAL_ORG(2)
      ! GEOMETRIE:
      MATERIAL(3) = MATERIAL_ORG(3)
      MATERIAL(4) = MATERIAL_ORG(4)
      MATERIAL(5) = MATERIAL_ORG(5)
      MATERIAL(6) = MATERIAL_ORG(6)
      ! BETON:
      MATERIAL(33) = MATERIAL_ORG(59)
      MATERIAL(34) = MATERIAL_ORG(60)
      MATERIAL(35) = MATERIAL_ORG(61)
      MATERIAL(36) = MATERIAL_ORG(62)
      MATERIAL(37) = MATERIAL_ORG(63)
      MATERIAL(38) = MATERIAL_ORG(64)
      MATERIAL(39) = MATERIAL_ORG(65)
      MATERIAL(40) = MATERIAL_ORG(66)
      MATERIAL(41) = MATERIAL_ORG(71)
      ! RISSABSTAND:
      MATERIAL(42) = MATERIAL_ORG(67)
      MATERIAL(43) = MATERIAL_ORG(68)
      MATERIAL(44) = MATERIAL_ORG(69)
      MATERIAL(45) = MATERIAL_ORG(70)

      IF (SCHICHTINFO .EQ. 0) THEN

      ! BEWEHRUNG IN X-RICHTUNG:
      MATERIAL(7) = MATERIAL_ORG(7)
      MATERIAL(8) = MATERIAL_ORG(8)
      MATERIAL(9) = 0D0
      MATERIAL(10) = 0D0
      MATERIAL(11) = 0D0
      MATERIAL(12) = 0D0
      MATERIAL(13) = 0D0
      MATERIAL(14) = 0D0
      MATERIAL(15) = 0D0
      MATERIAL(16) = 0D0
      MATERIAL(17) = 0D0
      MATERIAL(18) = 0D0
      MATERIAL(19) = 0D0
      ! BEWEHRUNG IN Y-RICHTUNG:
      MATERIAL(20) = MATERIAL_ORG(20)
      MATERIAL(21) = MATERIAL_ORG(21)
      MATERIAL(22) = 0D0
      MATERIAL(23) = 0D0
      MATERIAL(24) = 0D0
      MATERIAL(25) = 0D0
      MATERIAL(26) = 0D0
      MATERIAL(27) = 0D0
      MATERIAL(28) = 0D0
      MATERIAL(29) = 0D0
      MATERIAL(30) = 0D0
      MATERIAL(31) = 0D0
      MATERIAL(32) = 0D0

      ELSE IF (SCHICHTINFO .EQ. 1 .OR. SCHICHTINFO .EQ. 2) THEN

      ! BEWEHRUNG IN X-RICHTUNG:
      MATERIAL(7) = MATERIAL_ORG(46)
      MATERIAL(8) = MATERIAL_ORG(47)
      MATERIAL(9) = MATERIAL_ORG(48)
      MATERIAL(10) = MATERIAL_ORG(49)
      MATERIAL(11) = MATERIAL_ORG(50)
      MATERIAL(12) = MATERIAL_ORG(51)
      MATERIAL(13) = MATERIAL_ORG(52)
      MATERIAL(14) = MATERIAL_ORG(53)
      MATERIAL(15) = MATERIAL_ORG(54)
      MATERIAL(16) = MATERIAL_ORG(55)
      MATERIAL(17) = MATERIAL_ORG(56)
      MATERIAL(18) = MATERIAL_ORG(57)
      MATERIAL(19) = MATERIAL_ORG(58)
      ! BEWEHRUNG IN Y-RICHTUNG:
      MATERIAL(20) = MATERIAL_ORG(33)
      MATERIAL(21) = MATERIAL_ORG(34)
      MATERIAL(22) = MATERIAL_ORG(35)
      MATERIAL(23) = MATERIAL_ORG(36)
      MATERIAL(24) = MATERIAL_ORG(37)
      MATERIAL(25) = MATERIAL_ORG(38)
      MATERIAL(26) = MATERIAL_ORG(39)
      MATERIAL(27) = MATERIAL_ORG(40)
      MATERIAL(28) = MATERIAL_ORG(41)
      MATERIAL(29) = MATERIAL_ORG(42)
      MATERIAL(30) = MATERIAL_ORG(43)
      MATERIAL(31) = MATERIAL_ORG(44)
      MATERIAL(32) = MATERIAL_ORG(45)

      ELSE IF (SCHICHTINFO .EQ. 3 .OR. SCHICHTINFO .EQ. 4) THEN

      ! BEWEHRUNG IN X-RICHTUNG:
      MATERIAL(7) = MATERIAL_ORG(7)
      MATERIAL(8) = MATERIAL_ORG(8)
      MATERIAL(9) = MATERIAL_ORG(9)
      MATERIAL(10) = MATERIAL_ORG(10)
      MATERIAL(11) = MATERIAL_ORG(11)
      MATERIAL(12) = MATERIAL_ORG(12)
      MATERIAL(13) = MATERIAL_ORG(13)
      MATERIAL(14) = MATERIAL_ORG(14)
      MATERIAL(15) = MATERIAL_ORG(15)
      MATERIAL(16) = MATERIAL_ORG(16)
      MATERIAL(17) = MATERIAL_ORG(17)
      MATERIAL(18) = MATERIAL_ORG(18)
      MATERIAL(19) = MATERIAL_ORG(19)
      ! BEWEHRUNG IN Y-RICHTUNG:
      MATERIAL(20) = MATERIAL_ORG(20)
      MATERIAL(21) = MATERIAL_ORG(21)
      MATERIAL(22) = MATERIAL_ORG(22)
      MATERIAL(23) = MATERIAL_ORG(23)
      MATERIAL(24) = MATERIAL_ORG(24)
      MATERIAL(25) = MATERIAL_ORG(25)
      MATERIAL(26) = MATERIAL_ORG(26)
      MATERIAL(27) = MATERIAL_ORG(27)
      MATERIAL(28) = MATERIAL_ORG(28)
      MATERIAL(29) = MATERIAL_ORG(29)
      MATERIAL(30) = MATERIAL_ORG(30)
      MATERIAL(31) = MATERIAL_ORG(31)
      MATERIAL(32) = MATERIAL_ORG(32)

      ELSE IF (SCHICHTINFO .EQ. 5 .OR. SCHICHTINFO .EQ. 6) THEN

      ! BEWEHRUNG IN X-RICHTUNG:
      MATERIAL(7) = MATERIAL_ORG(7)
      MATERIAL(8) = MATERIAL_ORG(8)
      MATERIAL(9) = MATERIAL_ORG(9)+MATERIAL_ORG(48)
      MATERIAL(10) = MATERIAL_ORG(10)
      MATERIAL(11) = MATERIAL_ORG(11)
      MATERIAL(12) = MATERIAL_ORG(12)
      MATERIAL(13) = MATERIAL_ORG(13)
      MATERIAL(14) = MATERIAL_ORG(14)
      MATERIAL(15) = MATERIAL_ORG(15)
      MATERIAL(16) = MATERIAL_ORG(16)
      MATERIAL(17) = MATERIAL_ORG(17)
      MATERIAL(18) = MATERIAL_ORG(18)
      MATERIAL(19) = MATERIAL_ORG(19)
      ! BEWEHRUNG IN Y-RICHTUNG:
      MATERIAL(20) = MATERIAL_ORG(20)
      MATERIAL(21) = MATERIAL_ORG(21)
      MATERIAL(22) = MATERIAL_ORG(22)+MATERIAL_ORG(35)
      MATERIAL(23) = MATERIAL_ORG(23)
      MATERIAL(24) = MATERIAL_ORG(24)
      MATERIAL(25) = MATERIAL_ORG(25)
      MATERIAL(26) = MATERIAL_ORG(26)
      MATERIAL(27) = MATERIAL_ORG(27)
      MATERIAL(28) = MATERIAL_ORG(28)
      MATERIAL(29) = MATERIAL_ORG(29)
      MATERIAL(30) = MATERIAL_ORG(30)
      MATERIAL(31) = MATERIAL_ORG(31)
      MATERIAL(32) = MATERIAL_ORG(32)

      END IF

      ! IREF NR. LAYER MIT BEWEHRUNG
      MATERIAL(46)= REAL(IREF(1))
      MATERIAL(47)= REAL(IREF(2))
      MATERIAL(48)= REAL(IREF(3))
      MATERIAL(49)= REAL(IREF(4))
      ! STATISCHE HEBELARME IN BEWEHRUNGSSCHWERPUNTK
      MATERIAL(50)=ZSI(1)
      MATERIAL(51)=ZSI(2)
      MATERIAL(52)=ZSI(3)
      MATERIAL(53) =ZSI(4)
      ! L�NGE DES VEKTORS F�R DIE QUERKRAFT AUS SMICS SHELL 181
      MATERIAL(54) =(8*(MATERIAL_ORG(3)-1)+58)
      ! DRUCKDIAGONALENNEIGUNG KERN (SANDWICHMODELL)
      MATERIAL(55)= MATERIAL_ORG(72)
      ! BRUCHKRITERIUM QUERKRAFT KERN
      MATERIAL(56) = MATERIAL_ORG(73)
      ! FAKTOR BRUCHKRITERIUM QUERKRAFT IN KERN
      MATERIAL(57) = MATERIAL_ORG(74)
      ! FLIESSGRENZE B�GEL
      MATERIAL(58) = MATERIAL_ORG(75)
      ! ELEMENTNUMMER F�R QUERKRAFT
      MATERIAL(59) = REAL(IELEMENT)
      ! LAYERNUMMER F�R QUERKRAFT
      MATERIAL(60) = KLAYER

      END SUBROUTINE SUB_MATERIAL


!-----------------------------------------------------------------------
!
!     SUBROUTINENE & FUNKTIONEN F�R INTRINISCHE FUNKTIONEN F�R KOMPLEXE
!     VARIABLEN
!
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     FUNKTION ZUR BESTIMMUNG DES ABSOLUTWERTES EINER KOMPLEXEN
!     VORZEICHENS
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      FUNCTION ABS_C(VAL)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX             :: ABS_C
      DOUBLE COMPLEX, INTENT(IN) :: VAL

      ! BERECHNUNG DES ABSOLUTEN WERTES
      ABS_C = VAL

      IF (REAL(VAL) < 0D0) THEN
        ABS_C = CMPLX(-REAL(VAL),-AIMAG(VAL),KIND=8)
      END IF

      RETURN

      END FUNCTION ABS_C

!-----------------------------------------------------------------------
!     FUNKTION ZUR BERECHNUNG DES ARKUSTANGENS ZWEIER KOMPLEXEN ZAHLEN
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:             14.04.2014
!-----------------------------------------------------------------------
      FUNCTION ATAN2_C(CSN,CCS)

      ! VARIABLENDEKLARATION
      IMPLICIT NONE
      DOUBLE COMPLEX             :: ATAN2_C
      DOUBLE COMPLEX, INTENT(IN) :: CSN, CCS
      DOUBLE PRECISION           :: A,B,C,D

      ! BERECHNUNG DES ARKUSTANGENS
      IF (REAL(CSN) .EQ. 0D0 .AND. REAL(CCS) .EQ. 0D0) THEN
        ATAN2_C = CMPLX(0D0,0D0,KIND=8)
      ELSE
        A=REAL(CSN)
        B=AIMAG(CSN)
        C=REAL(CCS)
        D=AIMAG(CCS)
        ATAN2_C = CMPLX(ATAN2(A,C),((C*B-A*D)/(A**2D0+C**2D0)),KIND=8)
      END IF

      RETURN

      END FUNCTION ATAN2_C

!-----------------------------------------------------------------------
!     FUNKTION ZUR BERECHNUNG DES ARKUSTANGENS ZWEIER KOMPLEXEN ZAHLEN
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:             14.04.2014
!-----------------------------------------------------------------------
      FUNCTION TAN_C(Z)

      ! VARIABLENDEKLARATION
      IMPLICIT NONE
      DOUBLE COMPLEX             :: TAN_C
      DOUBLE COMPLEX, INTENT(IN) :: Z

      ! BERECHNUNG DES TAN IN C
      TAN_C=CMPLX(TAN(REAL(Z)),AIMAG(Z)/COS(REAL(Z))**2D0,KIND=8)

      RETURN

      END FUNCTION TAN_C

!-----------------------------------------------------------------------
!     FUNKTION ZUR BESTIMMUNG DES MINIMALEN REALWERTES ZWEIER KOMPLEXEN
!     ZAHLEN
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      FUNCTION MIN_RC(VAL1,VAL2)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX              :: MIN_RC
      DOUBLE COMPLEX , INTENT(IN) :: VAL1
      DOUBLE COMPLEX , INTENT(IN) :: VAL2

      ! ERMITTLUNG DES MINIMALEN WERTES

      IF (REAL(VAL1) < REAL(VAL2)) THEN
        MIN_RC = VAL1
      ELSE
        MIN_RC = VAL2
      END IF

      RETURN

      END FUNCTION MIN_RC

!-----------------------------------------------------------------------
!     FUNKTION ZUR BESTIMMUNG EINES KOMPLEXEN VORZEICHENS
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      FUNCTION SIGN_RC(VAL1,VAL2)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX               :: SIGN_RC, SIGN_0
      DOUBLE PRECISION, INTENT(IN) :: VAL1
      DOUBLE COMPLEX  , INTENT(IN) :: VAL2

      ! AUSWERTUNG DER FUNKTION
      IF (REAL(VAL2) < 0) THEN
        SIGN_0 = CMPLX(-1D0,0D0,KIND=8)
      ELSE
        SIGN_0 = CMPLX(1D0,0D0,KIND=8)
      END IF

      SIGN_RC = SIGN_0*CMPLX(VAL1,0D0,KIND=8)

      RETURN

      END FUNCTION SIGN_RC

!-----------------------------------------------------------------------
!     FUNKTION ZUR BERECHNUNG EINER KOMPLEXEN WURZEL
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      FUNCTION SQRT_C(VAL)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX              :: SQRT_C,I
      DOUBLE COMPLEX , INTENT(IN) :: VAL
      DOUBLE PRECISION :: PI, R, A, B, PHI

      ! PARAMETERDEFINITION
      I = CMPLX(0D0,1D0,KIND=8)
      PI = 4.D0*ATAN(1.0D0)
      R = ABS(VAL)
      A = REAL(VAL)
      B = AIMAG(VAL)

      ! BERECHNUNG
      IF (A > 0D0) THEN
        PHI = ATAN(B/A)
      ELSE IF (A < 0D0 .AND. B >= 0D0) THEN
        PHI = ATAN(B/A)+PI
      ELSE IF (A < 0D0 .AND. B < 0D0) THEN
        PHI = ATAN(B/A)-PI
      ELSE IF (A == 0D0 .AND. B > 0D0) THEN
        PHI = PI/2D0
      ELSE IF (A == 0D0 .AND. B < 0D0) THEN
        PHI = -PI/2D0
      END IF

      SQRT_C = SQRT(R)*EXP(I*(PHI+0D0*PI)/2D0)

      RETURN

      END FUNCTION SQRT_C

!-----------------------------------------------------------------------
!     HILFSFUNKTION F�R IMAGIN�RE ABSOLUTWERTE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              14.04.2014
!-----------------------------------------------------------------------
      FUNCTION ABS_CC(VAL)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX             :: ABS_CC
      DOUBLE COMPLEX, INTENT(IN) :: VAL

      ! BERECHNUNG DES ABSOLUTEN WERTES
      IF (REAL(VAL) < 0D0 .AND. AIMAG(VAL) < 0D0) THEN
        ABS_CC = CMPLX(-REAL(VAL),-AIMAG(VAL),KIND=8)

      ELSE IF (REAL(VAL) < 0D0 .AND. AIMAG(VAL) >= 0D0) THEN
        ABS_CC = CMPLX(-REAL(VAL),AIMAG(VAL),KIND=8)

      ELSE IF (REAL(VAL) >= 0D0 .AND. AIMAG(VAL) < 0D0) THEN
        ABS_CC = CMPLX(REAL(VAL),-AIMAG(VAL),KIND=8)

      ELSE IF (REAL(VAL) >= 0D0 .AND. AIMAG(VAL) >= 0D0) THEN
        ABS_CC = VAL
      END IF

      RETURN

      END FUNCTION ABS_CC

      !-----------------------------------------------------------------------
!     HILFSFUNKTION F�R IMAGIN�RE EXPONENTIALFUNKTION
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!
!     DATUM:              16.01.2017
!-----------------------------------------------------------------------
      FUNCTION EXP_C(Z_C)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX, INTENT(IN) :: Z_C
      DOUBLE COMPLEX             :: EXP_C, I

      ! PARAMETERDEFINITION
      I = CMPLX(0D0,1D0,KIND=8)

      ! BERECHNUNG DES ATAN IN C
      EXP_C = EXP(REAL(Z_C))*(COS(AIMAG(Z_C))+I*SIN(AIMAG(Z_C)))

      RETURN

      END FUNCTION EXP_C


!-----------------------------------------------------------------------
!     HILFSFUNKTION F�R STAHLSTOFFGESETZ F�R KALTVERFORMTE ST�HLE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      FUNCTION F_S_E_KV(SIGMA,ES,KC,ALPHA)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX             :: F_S_E_KV
      DOUBLE COMPLEX, INTENT(IN) :: SIGMA,ES,KC,ALPHA

      INTERFACE
        FUNCTION ABS_C(VAL)
            DOUBLE COMPLEX             :: ABS_C
            DOUBLE COMPLEX, INTENT(IN) :: VAL
        END FUNCTION ABS_C

        FUNCTION SIGN_RC(VAL1,VAL2)
            DOUBLE COMPLEX               :: SIGN_RC
            DOUBLE PRECISION, INTENT(IN) :: VAL1
            DOUBLE COMPLEX  , INTENT(IN) :: VAL2
        END FUNCTION SIGN_RC
      END INTERFACE


      F_S_E_KV = SIGN_RC(1D0,SIGMA)*(ABS_C(SIGMA)/ES+(ABS_C(SIGMA)/KC)
     &           **ALPHA)

      RETURN

      END FUNCTION F_S_E_KV

!-----------------------------------------------------------------------
!     HILFSFUNKTION F�R ZUGGURTMODELL F�R KALTVERFORMTE ST�HLE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      FUNCTION F_S_E_KV_ZM(SIGMA_SR,SRM,DM,FSY,FSU,ESU,ES,TAU_B0,
     &                     TAU_B1,EC,RHO,KC,ALPHA)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX             :: F_S_E_KV_ZM
      DOUBLE COMPLEX, INTENT(IN) :: SIGMA_SR,SRM,DM,FSY,FSU,ESU,ES,
     &                              TAU_B0,TAU_B1,EC,RHO,KC,ALPHA

      DOUBLE COMPLEX             :: SIG_ID, EPS_M,N, X1, X2, X3

      N=ES/EC
      SIG_ID =N*SIGMA_SR*RHO/(CMPLX(1D0,0D0,KIND=8)+RHO*
     &       (N-CMPLX(1D0,0D0,KIND=8)))

      X1 = DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B0)*(SIGMA_SR-SIG_ID)
      X2=  DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B0)*(FSY-SIG_ID)
      X3=  DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B1)*(SIGMA_SR-FSY)


      IF ((REAL(SIGMA_SR-CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM) .LE.
     &REAL(SIG_ID)) .AND. (REAL(SIGMA_SR) .LE. REAL(FSY))) THEN

      EPS_M = CMPLX(2D0,0D0,KIND=8)/SRM*(X1*(SIGMA_SR/ES-
     &        CMPLX(2D0,0D0,KIND=8)*TAU_B0*X1/(ES*DM)+DM/
     &        (CMPLX(4D0,0D0,KIND=8)*TAU_B0*X1*(CMPLX(1D0,0D0,KIND=8)+
     &        ALPHA)*KC**ALPHA)*(SIGMA_SR**(ALPHA+
     &        CMPLX(1D0,0D0,KIND=8))-(SIGMA_SR-CMPLX(4D0,0D0,KIND=8)*
     &        TAU_B0*X1/DM)**(CMPLX(1D0,0D0,KIND=8)+ALPHA)))+(SIGMA_SR/
     &        ES*N*RHO/(CMPLX(1D0,0D0,KIND=8)+N*RHO)*(SRM/
     &        CMPLX(2D0,0D0,KIND=8)-X1)))

      ELSEIF ((REAL(FSY-CMPLX(4D0,0D0,KIND=8)*TAU_B0*(SRM/
     &CMPLX(2D0,0D0,KIND=8)-X3)/DM).LT.REAL(SIG_ID)) .AND.
     &(REAL(X3) .GE. 0D0)) THEN

      EPS_M = (X2*(FSY/ES-CMPLX(2D0,0D0,KIND=8)*TAU_B0*X2/(ES*DM)+DM/
     &        (CMPLX(4D0,0D0,KIND=8)*TAU_B0*X2*(CMPLX(1D0,0D0,KIND=8)+
     &        ALPHA)*KC**ALPHA)*(FSY**(ALPHA+CMPLX(1D0,0D0,KIND=8))-
     &        (FSY-CMPLX(4D0,0D0,KIND=8)*TAU_B0*X2/DM)**
     &        (CMPLX(1D0,0D0,KIND=8)+ALPHA)))+(SIGMA_SR/ES*N*RHO/
     &        (CMPLX(1D0,0D0,KIND=8)+N*RHO)*(SRM/CMPLX(2D0,0D0,KIND=8)
     &        -X2-X3)))

      EPS_M = EPS_M + X3*(SIGMA_SR/ES-CMPLX(2D0,0D0,KIND=8)*TAU_B1*X3/
     &        (ES*DM)+DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B1*X3*
     &        (CMPLX(1D0,0D0,KIND=8)+ALPHA)*KC**ALPHA)*(SIGMA_SR**
     &        (ALPHA+CMPLX(1D0,0D0,KIND=8))-(SIGMA_SR-
     &        CMPLX(4D0,0D0,KIND=8)*TAU_B1*X3/DM)**
     &        (CMPLX(1D0,0D0,KIND=8)+ALPHA)))

      EPS_M = CMPLX(2D0,0D0,KIND=8)/SRM*EPS_M

      ELSEIF ((REAL(SIGMA_SR-CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM) .GT.
     &REAL(SIG_ID)) .AND. (REAL(SIGMA_SR) .LE. REAL(FSY))) THEN

      EPS_M = SIGMA_SR/ES-TAU_B0*SRM/(ES*DM)+DM/(CMPLX(2D0,0D0,KIND=8)*
     &        TAU_B0*SRM*(CMPLX(1D0,0D0,KIND=8)+ALPHA)*KC**ALPHA)*
     &        (SIGMA_SR**(ALPHA+CMPLX(1D0,0D0,KIND=8))-(SIGMA_SR-
     &        CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM)**
     &        (CMPLX(1D0,0D0,KIND=8)+ALPHA))

      ELSEIF ((REAL(SIGMA_SR) .GT. REAL(FSY)) .AND. (REAL(SIGMA_SR)
     & .LE. REAL(FSY+CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM/DM))) THEN

      EPS_M = DM/(CMPLX(4D0,0D0,KIND=8)*ES*TAU_B1*SRM)*((SIGMA_SR-FSY)
     &        **CMPLX(2D0,0D0,KIND=8)*(CMPLX(1D0,0D0,KIND=8)-TAU_B0/
     &        TAU_B1)+CMPLX(2D0,0D0,KIND=8)*ES/((ALPHA+
     &        CMPLX(1D0,0D0,KIND=8))*KC**ALPHA)*(SIGMA_SR**(ALPHA+
     &        CMPLX(1D0,0D0,KIND=8))-FSY**(ALPHA+CMPLX(1D0,0D0,KIND=8))
     &        *(CMPLX(1D0,0D0,KIND=8)-TAU_B1/TAU_B0)-TAU_B1/TAU_B0*
     &        (FSY+TAU_B0/TAU_B1*(SIGMA_SR-FSY)-CMPLX(2D0,0D0,KIND=8)*
     &        TAU_B0*SRM/DM)**(CMPLX(1D0,0D0,KIND=8)+ALPHA)))+TAU_B0/
     &        TAU_B1*(SIGMA_SR/ES-FSY/ES*(CMPLX(1D0,0D0,KIND=8)-TAU_B1/
     &        TAU_B0))-TAU_B0*SRM/(ES*DM)

      ELSEIF (REAL(SIGMA_SR) .GT. REAL(FSY+CMPLX(2D0,0D0,KIND=8)*
     &        TAU_B1*SRM/DM)) THEN

      EPS_M = SIGMA_SR/ES-TAU_B1*SRM/(ES*DM)+DM/(CMPLX(2D0,0D0,KIND=8)*
     &        TAU_B1*SRM*(CMPLX(1D0,0D0,KIND=8)+ALPHA)*KC**ALPHA)*
     &        (SIGMA_SR**(ALPHA+CMPLX(1D0,0D0,KIND=8))-(SIGMA_SR-
     &        CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM/DM)**
     &        (CMPLX(1D0,0D0,KIND=8)+ALPHA))

      END IF

      F_S_E_KV_ZM = EPS_M

      RETURN

      END FUNCTION F_S_E_KV_ZM

!-----------------------------------------------------------------------
!     HILFSFUNKTION F�R ZUGGURTMODELL F�R WARMVERFORMTE ST�HLE
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!                         PATRICK ROOS, HOCHSCHULE LUZERN
!     DATUM:              22.04.2014
!-----------------------------------------------------------------------
      FUNCTION F_S_E_WV_ZM(SIGMA_SR,SRM,DM,FSY,FSU,ESV,ES,TAU_B0,
     &                     TAU_B1,EC,RHO,KC,ALPHA)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX             :: F_S_E_WV_ZM
      DOUBLE COMPLEX, INTENT(IN) :: SIGMA_SR,SRM,DM,FSY,FSU,ESV,ES,
     &                              TAU_B0,TAU_B1,EC,RHO,KC,ALPHA

      DOUBLE COMPLEX             :: SIG_ID, EPS_M,N, X1, X2, X3,
     &                              Z1, Z2, Z2A,KV2

      KV2=CMPLX(10D0,0D0,KIND=8)*(ESV-FSY/ES)/(FSU-FSY)
      N=ES/EC
      SIG_ID =N*SIGMA_SR*RHO/(CMPLX(1D0,0D0,KIND=8)+RHO*(N-
     &        CMPLX(1D0,0D0,KIND=8)))

      X1 = DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B0)*(SIGMA_SR-SIG_ID)
      X2=  DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B0)*(FSY-SIG_ID)

      IF (REAL(SIGMA_SR).LE.REAL(FSU)) THEN
          X3=  DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B1)*(SIGMA_SR-FSY)
          Z1=CMPLX(1D0,0D0,KIND=8)-(SIGMA_SR-FSY)/(KC*(FSU-FSY))
          Z2=CMPLX(1D0,0D0,KIND=8)-(SIGMA_SR-FSY-CMPLX(2D0,0D0,KIND=8)*
     &       TAU_B1*SRM/DM)/(KC*(FSU-FSY))
          Z2A=CMPLX(1D0,0D0,KIND=8)-(SIGMA_SR-FSY-CMPLX(4D0,0D0,KIND=8)*
     &       TAU_B1*X3/DM)/(KC*(FSU-FSY))
      ELSE
          X3=  DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B1)*(FSU-FSY)
          Z1=CMPLX(1D0,0D0,KIND=8)-(FSU-FSY)/(KC*(FSU-FSY))
          Z2=CMPLX(1D0,0D0,KIND=8)-(FSU-FSY-CMPLX(2D0,0D0,KIND=8)*
     &       TAU_B1*SRM/DM)/(KC*(FSU-FSY))
          Z2A=CMPLX(1D0,0D0,KIND=8)-(FSU-FSY-CMPLX(4D0,0D0,KIND=8)*
     &       TAU_B1*X3/DM)/(KC*(FSU-FSY))
      END IF

      IF ((REAL(SIGMA_SR-CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM) .LE.
     & REAL(SIG_ID)) .AND. (REAL(SIGMA_SR) .LE. REAL(FSY))) THEN

      EPS_M = CMPLX(2D0,0D0,KIND=8)/SRM*(X1*(SIGMA_SR/ES-
     &        CMPLX(2D0,0D0,KIND=8)*TAU_B0*X1/(ES*DM))+(SIGMA_SR/ES*N*
     &        RHO/(CMPLX(1D0,0D0,KIND=8)+N*RHO)*(SRM/
     &        CMPLX(2D0,0D0,KIND=8)-X1)))

      ELSEIF ((REAL(FSY-CMPLX(4D0,0D0,KIND=8)*TAU_B0*(SRM/
     &CMPLX(2D0,0D0,KIND=8)-X3)/DM).LT.REAL(SIG_ID)) .AND. (REAL(X3)
     &.GE. 0D0)) THEN

      EPS_M = (X2*(FSY/ES-CMPLX(2D0,0D0,KIND=8)*TAU_B0*X2/(ES*DM))+
     &        (SIGMA_SR/ES*N*RHO/(CMPLX(1D0,0D0,KIND=8)+N*RHO)*(SRM/
     &        CMPLX(2D0,0D0,KIND=8)-X2-X3)))

      EPS_M = EPS_M + X3*(ESV-DM/(CMPLX(4D0,0D0,KIND=8)*TAU_B1*X3)*KC*
     &        (FSU-FSY)*ALPHA*(Z2A*(LOG(Z2A)-CMPLX(1D0,0D0,KIND=8))-Z1*
     &        (LOG(Z1)-CMPLX(1D0,0D0,KIND=8))))

        IF (REAL(SIGMA_SR).GT.REAL(FSU)) THEN
            EPS_M = (EPS_M+KV2*(SIGMA_SR-FSU)*SRM/
     &              CMPLX(2D0,0D0,KIND=8))/CMPLX(2D0,0D0,KIND=8)/SRM
        ELSE
            EPS_M = CMPLX(2D0,0D0,KIND=8)/SRM*EPS_M
        END IF

      ELSEIF ((REAL(SIGMA_SR-CMPLX(2D0,0D0,KIND=8)*TAU_B0*SRM/DM) .GT.
     & REAL(SIG_ID)) .AND. (REAL(SIGMA_SR) .LE. REAL(FSY))) THEN

      EPS_M = SIGMA_SR/ES-TAU_B0*SRM/(ES*DM)

      ELSEIF ((REAL(SIGMA_SR) .GT. REAL(FSY)) .AND. (REAL(SIGMA_SR)
     &       .LT. REAL(FSY+CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM/DM))) THEN

      EPS_M = DM/(CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM)*(ESV*(SIGMA_SR-FSY)+
     &        KC*(FSU-FSY)*ALPHA*(CMPLX(1D0,0D0,KIND=8)+Z1*(LOG(Z1)-
     &        CMPLX(1D0,0D0,KIND=8))))+(SRM-CMPLX(2D0,0D0,KIND=8)*X3)/
     &        SRM*(FSY/ES-(TAU_B0*(SRM-CMPLX(2D0,0D0,KIND=8)*X3))/
     &        (ES*DM))

        IF (REAL(SIGMA_SR).GT.REAL(FSU)) THEN
            EPS_M=EPS_M+KV2*(SIGMA_SR-FSU)
        END IF

      ELSEIF (REAL(SIGMA_SR) .GE. REAL(FSY+CMPLX(2D0,0D0,KIND=8)*
     & TAU_B1*SRM/DM))  THEN

      EPS_M = ESV-DM/(CMPLX(2D0,0D0,KIND=8)*TAU_B1*SRM)*KC*(FSU-FSY)*
     &        ALPHA*(Z2*(LOG(Z2)-CMPLX(1D0,0D0,KIND=8))-Z1*(LOG(Z1)-
     &        CMPLX(1D0,0D0,KIND=8)))

            IF (REAL(SIGMA_SR).GT.REAL(FSU)) THEN
                EPS_M=EPS_M+KV2*(SIGMA_SR-FSU)
            END IF

      END IF

      F_S_E_WV_ZM = EPS_M

      RETURN

      END FUNCTION F_S_E_WV_ZM


      SUBROUTINE SUB_CRACKED(USTATEV,NSTATEV,MATERIAL,NMATERIAL)

      IMPLICIT NONE

      INTEGER,INTENT(IN)            :: NSTATEV,NMATERIAL
      DOUBLE PRECISION, DIMENSION(NSTATEV),INTENT(IN)  :: USTATEV
      DOUBLE PRECISION, DIMENSION(NMATERIAL),INTENT(INOUT)  :: MATERIAL

      ! SOBALD LAYER GERISSEN --> K_RISS=0 SODASS IM WEITEREN VERLAUF
      !                           DER ANALYSE DER LAYER GERISSEN IST.

      IF (USTATEV(1).GT.3) THEN

        MATERIAL(66)=1D-4

      END IF

      END SUBROUTINE SUB_CRACKED


!-----------------------------------------------------------------------
!     SUBROUTINE WELCHE DIE QUERKRAFT IM LETZTEN ITERATIONSSCHRITT
!     EINLIEST UND DIE HAUPTQUERKR�FTE BERECHNET.
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!
!     DATUM:              15.11.15
!-----------------------------------------------------------------------


      SUBROUTINE SUB_GET_VXVY(IELEMENT,NVAL,VX,VY,V0,PHI_0)
!      IMPLICIT NONE
! --> ALSO LOADED AT THE BEGINNING OF USERMAT !?!
#INCLUDE "IMPCOM.INC"

      EXTERNAL :: EMSGET
      INTEGER  :: EMSGET

      INTEGER, INTENT(IN)           :: IELEMENT,NVAL


      DOUBLE COMPLEX, INTENT(OUT) :: VX,VY,V0,PHI_0

!     DOUBLE PRECISION,DIMENSION(NVAL=8*(NN-1)+58):: VALUE_SHELL181 ! GILT NUR SHELL181
      DOUBLE PRECISION,DIMENSION(NVAL) ::   VALUE_SHELL181
      INTEGER                        ::  MDSDATA

      INTERFACE
        FUNCTION ATAN2_C(Y,X)
            DOUBLE COMPLEX             :: ATAN2_C
            DOUBLE COMPLEX, INTENT(IN) :: X,Y
        END FUNCTION ATAN2_C

        FUNCTION SQRT_C(VAL)
            DOUBLE COMPLEX :: SQRT_C
            DOUBLE COMPLEX, INTENT(IN) :: VAL
        END FUNCTION SQRT_C
      END INTERFACE


      MDSDATA = EMSGET(IELEMENT,VALUE_SHELL181)

      VX=CMPLX(VALUE_SHELL181(7),0D0,KIND=8)
      VY=CMPLX(VALUE_SHELL181(8),0D0,KIND=8)

      V0=SQRT_C(VX*VX+VY*VY)
      PHI_0=ATAN2_C(VX,VY)

!      PRINT*, V0

      END SUBROUTINE SUB_GET_VXVY

!-----------------------------------------------------------------------
!     SUBROUTINE WELCHE DIE ZUGKRAFT AUS QUERKRAFT BERECHNET, UND DIE
!     SPANNUNGEN IM GLOBALEN KOORDINATENSYSTEM ZUR�CKGIBT.
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!
!     DATUM:              15.11.15
!-----------------------------------------------------------------------

      SUBROUTINE SUB_T_Q(VX,VY,V0,PHI_0,WINKELD,FSY,DV,
     &                       T_X_Q,T_Y_Q,T_XY_Q,RHO_Z)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      DOUBLE COMPLEX,INTENT(IN)     :: VX,VY,V0,PHI_0,WINKELD,FSY,DV

      DOUBLE COMPLEX,INTENT(OUT)    :: T_X_Q,T_Y_Q,T_XY_Q,RHO_Z

      DOUBLE COMPLEX                :: TAN_T,COT_T, PI

      INTERFACE

      FUNCTION TAN_C(Z)
        DOUBLE COMPLEX             :: TAN_C
        DOUBLE COMPLEX, INTENT(IN) :: Z
      END FUNCTION TAN_C

      END INTERFACE

      PI = CMPLX(4.0D0*ATAN(1.0D0),0D0,KIND=8)

      TAN_T = TAN_C(WINKELD*(PI/CMPLX(180D0,0D0,KIND=8)))
      COT_T = CMPLX(1D0,0D0,KIND=8)/TAN_T

      T_X_Q = VX*VX*COT_T/(CMPLX(2D0,0D0,KIND=8)*V0)
      T_Y_Q = VY*VY*COT_T/(CMPLX(2D0,0D0,KIND=8)*V0)
      T_XY_Q= VX*VY*COT_T/(CMPLX(2D0,0D0,KIND=8)*V0)

      RHO_Z = V0*TAN_T/(FSY*DV)

      END SUBROUTINE SUB_T_Q

!-----------------------------------------------------------------------
!     SUBROUTINE EINFLUSS QUERKRAFT AUF GURTKR�FTE, WELCHE DIE
!     SPANNUNGEN IM GLOBALEN KOORDINATENSYSTEM ZUR�CKGIBT.
!
!       --> STAND GILT NUR F�R ORTHOGONALE BEWEHRUNGEN
!       --> SCHIEFWINKLIGE BEWEHRUNG IST NOCH PENDENT!!!
!
!     PROGRAMMIERUNG:     DR. KAREL THOMA, HOCHSCHULE LUZERN
!
!     DATUM:              15.11.15
!-----------------------------------------------------------------------

      SUBROUTINE SUB_ZQ(SCHICHTINFO,MATERIAL,
     &                 SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z,STATE)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION
      INTEGER,INTENT(IN)            :: SCHICHTINFO
      DOUBLE PRECISION,DIMENSION(60),INTENT(IN):: MATERIAL


      DOUBLE COMPLEX,INTENT(OUT)    :: SIGX_Q,SIGY_Q,TAUXY_Q,RHO_Z
      INTEGER,INTENT(INOUT)         :: STATE

      DOUBLE COMPLEX                :: VX,VY,V0,PHI_0,VR,WINKELD
      DOUBLE COMPLEX                :: T_X_Q,T_Y_Q,T_XY_Q
      INTEGER                       :: NVAL,KLAYER,IELEMENT,KRITQ,GRENZE

      DOUBLE COMPLEX                :: ZS1,ZS2,ZS3,ZS4
      DOUBLE COMPLEX                :: PSI1,PSI2,DH,HOEHE,N
      DOUBLE COMPLEX                :: FCC,FCT,HSW,N_HSW,DV,FSY,F_VR
      INTEGER                       :: IREF1,IREF2,IREF3,IREF4

      INTERFACE

      SUBROUTINE SUB_T_Q(VX,VY,V0,PHI_0,WINKELD,FSY,DV,
     &                       T_X_Q,T_Y_Q,T_XY_Q,RHO_Z)
        DOUBLE COMPLEX,INTENT(IN)     :: VX,VY,V0,PHI_0,WINKELD,FSY,DV
        DOUBLE COMPLEX,INTENT(OUT)    :: T_X_Q,T_Y_Q,T_XY_Q,RHO_Z
      END SUBROUTINE SUB_T_Q

      SUBROUTINE SUB_GET_VXVY(IELEMENT,NVAL,VX,VY,V0,PHI_0)
        INTEGER, INTENT(IN)           :: IELEMENT,NVAL
        DOUBLE COMPLEX, INTENT(OUT) :: VX,VY,V0,PHI_0
      END SUBROUTINE SUB_GET_VXVY

      FUNCTION SQRT_C(VAL)
        DOUBLE COMPLEX :: SQRT_C
        DOUBLE COMPLEX, INTENT(IN) :: VAL
      END FUNCTION SQRT_C

      END INTERFACE

      ! GRUNDDATEN AUS MATERIAL-MATRIX

      IREF1 = INT(MATERIAL(46))
      IREF2 = INT(MATERIAL(47))
      IREF3 = INT(MATERIAL(48))
      IREF4 = INT(MATERIAL(49))

      ZS1  = CMPLX(MATERIAL(50),0D0,KIND=8)
      ZS2  = CMPLX(MATERIAL(51),0D0,KIND=8)
      ZS3  = CMPLX(MATERIAL(52),0D0,KIND=8)
      ZS4  = CMPLX(MATERIAL(53),0D0,KIND=8)

      NVAL = INT(MATERIAL(54))
      WINKELD = CMPLX(MATERIAL(55),0D0,KIND=8)
      KRITQ = INT(MATERIAL(56))
      F_VR  = CMPLX(MATERIAL(57),0D0,KIND=8)
      FSY   = CMPLX(MATERIAL(58),0D0,KIND=8)
      IELEMENT = INT(MATERIAL(59))
      KLAYER   = INT(MATERIAL(60))

      N = CMPLX(MATERIAL(3),0D0,KIND=8)
      HOEHE = CMPLX(MATERIAL(4),0D0,KIND=8)

      DH=HOEHE/N

      FCC = CMPLX(MATERIAL(34),0D0,KIND=8)
      FCT = CMPLX(0.3D0,0D0,KIND=8)*(FCC*FCC)**
     &      CMPLX((1D0/3D0),0D0,KIND=8)

      ! RICHTUNG DER BEWEHRUNG IN X-RICHTUNG:
      PSI1 = CMPLX(MATERIAL(11),0D0,KIND=8)
      ! RICHTUNG DER BEWEHRUNG IN Y-RICHTUNG:
      PSI2 = CMPLX(MATERIAL(24),0D0,KIND=8)

      ! BRUCHKRITERIUM

      IF (KRITQ.EQ.1) THEN
        VR = F_VR*FCT/(CMPLX(3D0,0D0,KIND=8))
      ELSEIF (KRITQ.EQ.2) THEN
        VR = F_VR*SQRT_C(FCC)/(CMPLX(6D0,0D0,KIND=8))
      ELSE
        VR = F_VR*SQRT_C(FCC)/(CMPLX(6D0,0D0,KIND=8))
      END IF


      ! HSW ALS GANZZAHLIGES VERH�LTNIS VON DH
      GRENZE = INT(FLOOR(REAL(N)/2D0))
      IF (KLAYER.LT.GRENZE) THEN
        HSW=(HOEHE+ZS1+ZS2)   !ZS1 UND ZS2 SIND NEGATIV
      ELSE
        HSW=(HOEHE-(ZS3+ZS4))
      END IF

      N_HSW=CMPLX(CEILING(REAL(HSW/DH)),0D0,KIND=8)
      HSW=N_HSW*DH

      IF (REAL(HSW).GT.(REAL(HOEHE)/2D0)) THEN
        HSW=HOEHE/CMPLX(2D0,0D0,KIND=8)
      END IF

       IF (((KLAYER.GE.0).AND.(KLAYER.LE.REAL(N_HSW))).OR.
     &     (KLAYER.GE.(REAL(N-N_HSW)))) THEN

        CALL SUB_GET_VXVY(IELEMENT,NVAL,VX,VY,V0,PHI_0)

        ! STATISCHE H�HE F�R QUERKRAFTSBERECHNUNG
        DV  = (-ZS1-ZS2+ZS3+ZS4)/CMPLX(2D0,0D0,KIND=8)

        IF (REAL(V0/DV).GT.REAL(VR)) THEN

            CALL SUB_T_Q(VX,VY,V0,PHI_0,WINKELD,FSY,DV,
     &                       T_X_Q,T_Y_Q,T_XY_Q,RHO_Z)

            IF (SCHICHTINFO.EQ.0) THEN
            ! BETONSCHICHT ... ALLES AUF DEN STRINGER FALLS
            ! KLAYER INNERHALB STRINGER

                IF (STATE.LE.2) THEN !DRUCKMODELLE
                    IF (KLAYER.LT.GRENZE) THEN
                        SIGX_Q=T_X_Q/HSW*DV/(-ZS1-ZS2)
                        SIGY_Q=T_Y_Q/HSW*DV/(-ZS1-ZS2)
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)
                    ELSE
                        SIGX_Q=T_X_Q/HSW*DV/(ZS3+ZS4)
                        SIGY_Q=T_Y_Q/HSW*DV/(ZS3+ZS4)
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)
                    END IF
                ELSEIF (STATE.GE.3) THEN ! CMM UND ZUG/ZUG MODEL
                        SIGX_Q=CMPLX(0D0,0D0,KIND=8)
                        SIGY_Q=CMPLX(0D0,0D0,KIND=8)
                    IF (KLAYER.LT.GRENZE) THEN
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)
                    ELSE
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)
                    END IF
                ENDIF
            ELSE

                IF (STATE.LE.2) THEN !DRUCKMODELLE

                    IF (KLAYER.LT.GRENZE) THEN
                        SIGX_Q=T_X_Q/HSW*DV/(-ZS1-ZS2)
                        SIGY_Q=T_Y_Q/HSW*DV/(-ZS1-ZS2)
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)
                    ELSE
                        SIGX_Q=T_X_Q/HSW*DV/(ZS3+ZS4)
                        SIGY_Q=T_Y_Q/HSW*DV/(ZS3+ZS4)
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)
                    END IF

                ELSEIF (STATE.GE.3) THEN ! CMM UND ZUG/ZUG-MODELLE

                    IF ((SCHICHTINFO.EQ.1).AND.(REAL(PSI1).LT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 1. IN X-RICHTUNG

                        SIGX_Q=T_X_Q/DH*DV/(CMPLX(-2D0,0D0,KIND=8)*ZS1)
                        SIGY_Q=CMPLX(0D0,0D0,KIND=8)
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)

                    ELSEIF ((SCHICHTINFO.EQ.1).AND.
     &                          (REAL(PSI1).GT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 1.  IN Y-RICHTUNG

                        SIGX_Q=CMPLX(0D0,0D0,KIND=8)
                        SIGY_Q=T_Y_Q/DH*DV/(CMPLX(-2D0,0D0,KIND=8)*ZS1)
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)

                    ELSEIF ((SCHICHTINFO.EQ.2).AND.
     &                          (REAL(PSI2).GT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 2. LAGE IN Y-RICHTUNG

                        SIGX_Q=CMPLX(0D0,0D0,KIND=8)
                        SIGY_Q=T_Y_Q/DH*DV/(CMPLX(-2D0,0D0,KIND=8)*ZS2)
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)

                    ELSEIF ((SCHICHTINFO.EQ.2).AND.
     &                             (REAL(PSI2).LT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 2. LAGE IN X-RICHTUNG

                        SIGX_Q=T_X_Q/DH*DV/(CMPLX(-2D0,0D0,KIND=8)*ZS2)
                        SIGY_Q=CMPLX(0D0,0D0,KIND=8)
                        TAUXY_Q=T_XY_Q/HSW*DV/(-ZS1-ZS2)

                    ELSEIF ((SCHICHTINFO.EQ.3).AND.
     &                             (REAL(PSI2).GT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 3. LAGE IN Y-RICHTUNG

                        SIGX_Q=CMPLX(0D0,0D0,KIND=8)
                        SIGY_Q=T_Y_Q/DH*DV/(CMPLX(2D0,0D0,KIND=8)*ZS3)
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)

                    ELSEIF ((SCHICHTINFO.EQ.3).AND.
     &                             (REAL(PSI2).LT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 3. LAGE IN X-RICHTUNG

                        SIGX_Q=T_X_Q/DH*DV/(CMPLX(2D0,0D0,KIND=8)*ZS3)
                        SIGY_Q=CMPLX(0D0,0D0,KIND=8)
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)

                    ELSEIF ((SCHICHTINFO.EQ.4).AND.
     &                             (REAL(PSI1).LT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 4. LAGE IN X-RICHTUNG

                        SIGX_Q=T_X_Q/DH*DV/(CMPLX(2D0,0D0,KIND=8)*ZS4)
                        SIGY_Q=CMPLX(0D0,0D0,KIND=8)
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)

                    ELSEIF ((SCHICHTINFO.EQ.4).AND.
     &                             (REAL(PSI1).GT.1D0)) THEN
                    ! BEWEHRUNGSSCHICHT 4. LAGE IN Y-RICHTUNG

                        SIGX_Q=CMPLX(0D0,0D0,KIND=8)
                        SIGY_Q=T_Y_Q/DH*DV/(CMPLX(2D0,0D0,KIND=8)*ZS4)
                        TAUXY_Q=T_XY_Q/HSW*DV/(ZS3+ZS4)

                    END IF
                END IF
            END IF
           STATE=1

         ELSE
            ! KERN UNGERISSEN
            SIGX_Q = CMPLX(0D0,0D0,KIND=8)
            SIGY_Q = CMPLX(0D0,0D0,KIND=8)
            TAUXY_Q= CMPLX(0D0,0D0,KIND=8)
            RHO_Z  = CMPLX(0D0,0D0,KIND=8)
            STATE = 0
         END IF

      ELSE
        ! LAYER NICHT IN IM SANDWICHDECKEL
        SIGX_Q = CMPLX(0D0,0D0,KIND=8)
        SIGY_Q = CMPLX(0D0,0D0,KIND=8)
        TAUXY_Q= CMPLX(0D0,0D0,KIND=8)
        RHO_Z  = CMPLX(0D0,0D0,KIND=8)
        STATE=2
      END IF


      ! STATE = 1 --> KERN GERISSEN
      ! STATE = 0 --> KERN UNGERISSEN.
      ! STATE = 2 --> ZUSTAND IM LAYER NICHT DEFINIERT.

      END SUBROUTINE SUB_ZQ


      SUBROUTINE CHECK_HN(R_HN,HN_)

      IMPLICIT NONE

      ! VARIABLENDEKLARATION

      CHARACTER*8,INTENT(IN) :: HN_
      INTEGER*4,INTENT(OUT)  ::R_HN
      INTEGER*4 :: HOSTNM, STATUS
      CHARACTER*8 :: NAME

        R_HN=0
        STATUS = HOSTNM( NAME )
        
      IF (HN_ == NAME) THEN
        R_HN=1
      ENDIF
      
      ! PRINT*, NAME

	END SUBROUTINE
	
	! SUBROUTINE FÜR DIE BERÜCKSICHTIGUNG VON HOHLKÖRPER
	
	SUBROUTINE SUB_FAK_HK(KLAYER,N_LAYER,H_ELEMENT,R_ROHR,F_ROHR)
	
	IMPLICIT NONE

      ! VARIABLENDEKLARATION
	
	INTEGER*4, INTENT(IN)	:: KLAYER
	DOUBLE PRECISION, INTENT(IN) :: N_LAYER,H_ELEMENT,R_ROHR
	DOUBLE PRECISION, INTENT(OUT):: F_ROHR
	
	DOUBLE PRECISION :: DH_,B_,L_,B_INF,B_SUP,B_M
	
	DH_ = H_ELEMENT/N_LAYER
	B_=DH_*(DBLE(KLAYER)-0.5D0)
      
      B_M=H_ELEMENT/2.0D0
      B_INF=H_ELEMENT/2.0D0-R_ROHR
      B_SUP=H_ELEMENT/2.0D0+R_ROHR
	
	IF ((B_.GT.B_INF).AND.(B_.LE.B_M)) THEN
		L_=SQRT(R_ROHR**2.0D0-(H_ELEMENT/2.0D0-B_)**2.0D0)
		F_ROHR=1.0D0-L_/R_ROHR
	ELSEIF ((B_.GT.B_M).AND.(B_.LT.B_SUP)) THEN
		L_=SQRT(R_ROHR**2.0D0-(B_-H_ELEMENT/2.0D0)**2.0D0)
		F_ROHR=1.0D0-L_/R_ROHR
      ELSE
		F_ROHR=1.0D0
	END IF
	END SUBROUTINE SUB_FAK_HK
!------------------------------------ENDE---------------------------------------


